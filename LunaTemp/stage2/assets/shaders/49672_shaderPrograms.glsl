["\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = _HColor.xyz * _LightColor0.xyz + (-_SColor.xyz);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = _HColor.xyz * _LightColor0.xyz + (-_SColor.xyz);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_7;\nmediump float u_xlat16_12;\nfloat u_xlat15;\nmediump float u_xlat16_17;\nvoid main()\n{\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat15 = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat15 = inversesqrt(u_xlat15);\n    u_xlat1.xyz = vec3(u_xlat15) * vs_NORMAL0.xyz;\n    u_xlat15 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;\n    u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_7.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_7.x) + u_xlat16_2.x;\n    u_xlat16_12 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_7.x = (-u_xlat16_7.x) + u_xlat16_12;\n    u_xlat16_7.x = float(1.0) / u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_7.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_7.x;\n    u_xlat16_7.xyz = _HColor.xyz * _LightColor0.xyz + (-_SColor.xyz);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_17 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat15 = max(u_xlat16_17, 0.00100000005);\n    u_xlat16_17 = inversesqrt(u_xlat15);\n    u_xlat16_4.xyz = u_xlat0.xyz * vec3(u_xlat16_17);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_4.xyz : u_xlat1.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_4.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_4.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_4.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_4.xyz = max(u_xlat16_4.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_2.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_3.xyz : u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_7;\nmediump float u_xlat16_12;\nfloat u_xlat15;\nmediump float u_xlat16_17;\nvoid main()\n{\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat15 = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat15 = inversesqrt(u_xlat15);\n    u_xlat1.xyz = vec3(u_xlat15) * vs_NORMAL0.xyz;\n    u_xlat15 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;\n    u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_7.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_7.x) + u_xlat16_2.x;\n    u_xlat16_12 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_7.x = (-u_xlat16_7.x) + u_xlat16_12;\n    u_xlat16_7.x = float(1.0) / u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_7.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_7.x;\n    u_xlat16_7.xyz = _HColor.xyz * _LightColor0.xyz + (-_SColor.xyz);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_17 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat15 = max(u_xlat16_17, 0.00100000005);\n    u_xlat16_17 = inversesqrt(u_xlat15);\n    u_xlat16_4.xyz = u_xlat0.xyz * vec3(u_xlat16_17);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_4.xyz : u_xlat1.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_4.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_4.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_4.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_4.xyz = max(u_xlat16_4.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_2.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_3.xyz : u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump float u_xlat16_9;\nmediump float u_xlat16_14;\nfloat u_xlat18;\nmediump float u_xlat16_20;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat18 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_14 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_14 = min(u_xlat16_14, 1.0);\n    u_xlat16_14 = (-u_xlat16_14) + 1.0;\n    u_xlat16_14 = sqrt(u_xlat16_14);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_14) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_20 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_3.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_3.x);\n    u_xlat16_9 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_3.x = (-u_xlat16_3.x) + u_xlat16_9;\n    u_xlat16_3.x = float(1.0) / u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.x = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_3.xyz = _HColor.xyz * _LightColor0.xyz + (-_SColor.xyz);\n    u_xlat16_3.xyz = vec3(u_xlat16_20) * u_xlat16_3.xyz + _SColor.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_20 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat18 = max(u_xlat16_20, 0.00100000005);\n    u_xlat16_20 = inversesqrt(u_xlat18);\n    u_xlat16_5.xyz = u_xlat0.xyz * vec3(u_xlat16_20);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_5.xyz : u_xlat16_2.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_3.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_2.xyz : u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump float u_xlat16_9;\nmediump float u_xlat16_14;\nfloat u_xlat18;\nmediump float u_xlat16_20;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat18 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_14 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_14 = min(u_xlat16_14, 1.0);\n    u_xlat16_14 = (-u_xlat16_14) + 1.0;\n    u_xlat16_14 = sqrt(u_xlat16_14);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_14) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_20 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_3.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_3.x);\n    u_xlat16_9 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_3.x = (-u_xlat16_3.x) + u_xlat16_9;\n    u_xlat16_3.x = float(1.0) / u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.x = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_3.xyz = _HColor.xyz * _LightColor0.xyz + (-_SColor.xyz);\n    u_xlat16_3.xyz = vec3(u_xlat16_20) * u_xlat16_3.xyz + _SColor.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_20 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat18 = max(u_xlat16_20, 0.00100000005);\n    u_xlat16_20 = inversesqrt(u_xlat18);\n    u_xlat16_5.xyz = u_xlat0.xyz * vec3(u_xlat16_20);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_5.xyz : u_xlat16_2.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_3.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_2.xyz : u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_7;\nmediump float u_xlat16_12;\nfloat u_xlat15;\nmediump float u_xlat16_17;\nvoid main()\n{\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat15 = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat15 = inversesqrt(u_xlat15);\n    u_xlat1.xyz = vec3(u_xlat15) * vs_NORMAL0.xyz;\n    u_xlat15 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;\n    u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_7.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_7.x) + u_xlat16_2.x;\n    u_xlat16_12 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_7.x = (-u_xlat16_7.x) + u_xlat16_12;\n    u_xlat16_7.x = float(1.0) / u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_7.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_7.x;\n    u_xlat16_7.xyz = _HColor.xyz * _LightColor0.xyz + (-_SColor.xyz);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_17 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat15 = max(u_xlat16_17, 0.00100000005);\n    u_xlat16_17 = inversesqrt(u_xlat15);\n    u_xlat16_4.xyz = u_xlat0.xyz * vec3(u_xlat16_17);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_4.xyz : u_xlat1.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_4.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_4.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_4.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_4.xyz = max(u_xlat16_4.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_2.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_3.xyz : u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_7;\nmediump float u_xlat16_12;\nfloat u_xlat15;\nmediump float u_xlat16_17;\nvoid main()\n{\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat15 = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat15 = inversesqrt(u_xlat15);\n    u_xlat1.xyz = vec3(u_xlat15) * vs_NORMAL0.xyz;\n    u_xlat15 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;\n    u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_7.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_7.x) + u_xlat16_2.x;\n    u_xlat16_12 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_7.x = (-u_xlat16_7.x) + u_xlat16_12;\n    u_xlat16_7.x = float(1.0) / u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_7.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_7.x;\n    u_xlat16_7.xyz = _HColor.xyz * _LightColor0.xyz + (-_SColor.xyz);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_17 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat15 = max(u_xlat16_17, 0.00100000005);\n    u_xlat16_17 = inversesqrt(u_xlat15);\n    u_xlat16_4.xyz = u_xlat0.xyz * vec3(u_xlat16_17);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_4.xyz : u_xlat1.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_4.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_4.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_4.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_4.xyz = max(u_xlat16_4.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_2.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_3.xyz : u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = _HColor.xyz * _LightColor0.xyz + (-_SColor.xyz);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = _HColor.xyz * _LightColor0.xyz + (-_SColor.xyz);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec2 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = _HColor.xyz * _LightColor0.xyz + (-_SColor.xyz);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec2 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = _HColor.xyz * _LightColor0.xyz + (-_SColor.xyz);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6.x = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6.x = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_7;\nmediump float u_xlat16_12;\nfloat u_xlat15;\nmediump float u_xlat16_17;\nvoid main()\n{\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat15 = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat15 = inversesqrt(u_xlat15);\n    u_xlat1.xyz = vec3(u_xlat15) * vs_NORMAL0.xyz;\n    u_xlat15 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;\n    u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_7.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_7.x) + u_xlat16_2.x;\n    u_xlat16_12 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_7.x = (-u_xlat16_7.x) + u_xlat16_12;\n    u_xlat16_7.x = float(1.0) / u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_7.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_7.x = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_12 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_12) + u_xlat16_2.x;\n    u_xlat16_17 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_12 = (-u_xlat16_12) + u_xlat16_17;\n    u_xlat16_12 = float(1.0) / u_xlat16_12;\n    u_xlat16_2.x = u_xlat16_12 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_12 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_12 * u_xlat16_2.x + u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_17 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat15 = max(u_xlat16_17, 0.00100000005);\n    u_xlat16_17 = inversesqrt(u_xlat15);\n    u_xlat16_4.xyz = u_xlat0.xyz * vec3(u_xlat16_17);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_4.xyz : u_xlat1.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_4.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_4.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_4.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_4.xyz = max(u_xlat16_4.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_2.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_3.xyz : u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_7;\nmediump float u_xlat16_12;\nfloat u_xlat15;\nmediump float u_xlat16_17;\nvoid main()\n{\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat15 = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat15 = inversesqrt(u_xlat15);\n    u_xlat1.xyz = vec3(u_xlat15) * vs_NORMAL0.xyz;\n    u_xlat15 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;\n    u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_7.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_7.x) + u_xlat16_2.x;\n    u_xlat16_12 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_7.x = (-u_xlat16_7.x) + u_xlat16_12;\n    u_xlat16_7.x = float(1.0) / u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_7.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_7.x = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_12 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_12) + u_xlat16_2.x;\n    u_xlat16_17 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_12 = (-u_xlat16_12) + u_xlat16_17;\n    u_xlat16_12 = float(1.0) / u_xlat16_12;\n    u_xlat16_2.x = u_xlat16_12 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_12 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_12 * u_xlat16_2.x + u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_17 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat15 = max(u_xlat16_17, 0.00100000005);\n    u_xlat16_17 = inversesqrt(u_xlat15);\n    u_xlat16_4.xyz = u_xlat0.xyz * vec3(u_xlat16_17);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_4.xyz : u_xlat1.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_4.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_4.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_4.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_4.xyz = max(u_xlat16_4.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_2.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_3.xyz : u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump float u_xlat16_9;\nmediump float u_xlat16_14;\nmediump float u_xlat16_15;\nfloat u_xlat18;\nmediump float u_xlat16_20;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat18 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_14 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_14 = min(u_xlat16_14, 1.0);\n    u_xlat16_14 = (-u_xlat16_14) + 1.0;\n    u_xlat16_14 = sqrt(u_xlat16_14);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_14) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_20 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_3.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_3.x);\n    u_xlat16_9 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_3.x = (-u_xlat16_3.x) + u_xlat16_9;\n    u_xlat16_3.x = float(1.0) / u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.x = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * _RampBands;\n    u_xlat16_3.x = floor(u_xlat16_20);\n    u_xlat16_20 = fract(u_xlat16_20);\n    u_xlat16_9 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_9);\n    u_xlat16_15 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_9 = (-u_xlat16_9) + u_xlat16_15;\n    u_xlat16_9 = float(1.0) / u_xlat16_9;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_9;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_9 = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_9 * u_xlat16_20 + u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 / _RampBands;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_3.xyz = vec3(u_xlat16_20) * u_xlat16_3.xyz + _SColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_20 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat18 = max(u_xlat16_20, 0.00100000005);\n    u_xlat16_20 = inversesqrt(u_xlat18);\n    u_xlat16_5.xyz = u_xlat0.xyz * vec3(u_xlat16_20);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_5.xyz : u_xlat16_2.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_3.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_2.xyz : u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump float u_xlat16_9;\nmediump float u_xlat16_14;\nmediump float u_xlat16_15;\nfloat u_xlat18;\nmediump float u_xlat16_20;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat18 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_14 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_14 = min(u_xlat16_14, 1.0);\n    u_xlat16_14 = (-u_xlat16_14) + 1.0;\n    u_xlat16_14 = sqrt(u_xlat16_14);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_14) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_20 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_3.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_3.x);\n    u_xlat16_9 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_3.x = (-u_xlat16_3.x) + u_xlat16_9;\n    u_xlat16_3.x = float(1.0) / u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.x = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * _RampBands;\n    u_xlat16_3.x = floor(u_xlat16_20);\n    u_xlat16_20 = fract(u_xlat16_20);\n    u_xlat16_9 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_9);\n    u_xlat16_15 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_9 = (-u_xlat16_9) + u_xlat16_15;\n    u_xlat16_9 = float(1.0) / u_xlat16_9;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_9;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_9 = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_9 * u_xlat16_20 + u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 / _RampBands;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_3.xyz = vec3(u_xlat16_20) * u_xlat16_3.xyz + _SColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_20 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat18 = max(u_xlat16_20, 0.00100000005);\n    u_xlat16_20 = inversesqrt(u_xlat18);\n    u_xlat16_5.xyz = u_xlat0.xyz * vec3(u_xlat16_20);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_5.xyz : u_xlat16_2.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_3.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_2.xyz : u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec2 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6.x = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec2 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6.x = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tvec4 _EmissionMap_ST;\nuniform \tmediump float _EmissionChannel;\nuniform \tmediump vec4 _EmissionColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _EmissionMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nvec3 u_xlat1;\nvec2 u_xlat2;\nlowp vec4 u_xlat10_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nbvec4 u_xlatb7;\nmediump vec3 u_xlat16_8;\nmediump vec3 u_xlat16_9;\nmediump float u_xlat16_15;\nfloat u_xlat30;\nbool u_xlatb30;\nmediump float u_xlat16_33;\nmediump float u_xlat16_34;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat30 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat30) * u_xlat0.xyz;\n    u_xlat30 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat30 = inversesqrt(u_xlat30);\n    u_xlat1.xyz = vec3(u_xlat30) * _WorldSpaceLightPos0.xyz;\n    u_xlat10_2.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_2.xyz * _BaseColor.xyz;\n    u_xlatb30 = _EmissionChannel<5.0;\n    if(u_xlatb30){\n        u_xlat2.xy = vs_TEXCOORD1.zw * _EmissionMap_ST.xy + _EmissionMap_ST.zw;\n        u_xlat10_2 = texture2D(_EmissionMap, u_xlat2.xy);\n        u_xlat16_4.xyz = u_xlat10_2.xyz * _EmissionColor.xyz;\n        u_xlat16_5.xyz = u_xlat10_2.www * _EmissionColor.xyz;\n        u_xlat16_6.xyz = u_xlat10_2.zzz * _EmissionColor.xyz;\n        u_xlatb7 = greaterThanEqual(vec4(_EmissionChannel), vec4(4.0, 3.0, 2.0, 1.0));\n        u_xlat16_8.xyz = u_xlat10_2.yyy * _EmissionColor.xyz;\n        u_xlat16_9.xyz = u_xlat10_2.xxx * _EmissionColor.xyz;\n        u_xlat16_8.xyz = (u_xlatb7.w) ? u_xlat16_8.xyz : u_xlat16_9.xyz;\n        u_xlat16_6.xyz = (u_xlatb7.z) ? u_xlat16_6.xyz : u_xlat16_8.xyz;\n        u_xlat16_5.xyz = (u_xlatb7.y) ? u_xlat16_5.xyz : u_xlat16_6.xyz;\n        u_xlat16_4.xyz = (u_xlatb7.x) ? u_xlat16_4.xyz : u_xlat16_5.xyz;\n    } else {\n        u_xlat16_4.xyz = _EmissionColor.xyz;\n    }\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_33 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_34 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_5.x = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_5.x = (-u_xlat16_34) + u_xlat16_5.x;\n    u_xlat16_33 = u_xlat16_33 + (-u_xlat16_34);\n    u_xlat16_34 = float(1.0) / u_xlat16_5.x;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_34;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_34 = u_xlat16_33 * -2.0 + 3.0;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_34;\n    u_xlat16_34 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_5.x = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_33 = u_xlat16_33 * _RampBands;\n    u_xlat16_15 = fract(u_xlat16_33);\n    u_xlat16_5.x = (-u_xlat16_34) + u_xlat16_5.x;\n    u_xlat16_34 = (-u_xlat16_34) + u_xlat16_15;\n    u_xlat16_5.x = float(1.0) / u_xlat16_5.x;\n    u_xlat16_34 = u_xlat16_34 * u_xlat16_5.x;\n    u_xlat16_34 = clamp(u_xlat16_34, 0.0, 1.0);\n    u_xlat16_5.x = u_xlat16_34 * -2.0 + 3.0;\n    u_xlat16_34 = u_xlat16_34 * u_xlat16_34;\n    u_xlat16_33 = floor(u_xlat16_33);\n    u_xlat16_33 = u_xlat16_5.x * u_xlat16_34 + u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 / _RampBands;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_5.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_5.xyz = vec3(u_xlat16_33) * u_xlat16_5.xyz + _SColor.xyz;\n    u_xlat16_5.xyz = u_xlat16_5.xyz * _LightColor0.xyz;\n    SV_Target0.xyz = u_xlat16_3.xyz * u_xlat16_5.xyz + u_xlat16_4.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tvec4 _EmissionMap_ST;\nuniform \tmediump float _EmissionChannel;\nuniform \tmediump vec4 _EmissionColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _EmissionMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nvec3 u_xlat1;\nvec2 u_xlat2;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nbvec4 u_xlatb7;\nmediump vec3 u_xlat16_8;\nmediump vec3 u_xlat16_9;\nmediump float u_xlat16_15;\nfloat u_xlat30;\nbool u_xlatb30;\nmediump float u_xlat16_33;\nmediump float u_xlat16_34;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat30 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat30) * u_xlat0.xyz;\n    u_xlat30 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat30 = inversesqrt(u_xlat30);\n    u_xlat1.xyz = vec3(u_xlat30) * _WorldSpaceLightPos0.xyz;\n    u_xlat16_2.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_2.xyz * _BaseColor.xyz;\n    u_xlatb30 = _EmissionChannel<5.0;\n    if(u_xlatb30){\n        u_xlat2.xy = vs_TEXCOORD1.zw * _EmissionMap_ST.xy + _EmissionMap_ST.zw;\n        u_xlat16_2 = texture(_EmissionMap, u_xlat2.xy);\n        u_xlat16_4.xyz = u_xlat16_2.xyz * _EmissionColor.xyz;\n        u_xlat16_5.xyz = u_xlat16_2.www * _EmissionColor.xyz;\n        u_xlat16_6.xyz = u_xlat16_2.zzz * _EmissionColor.xyz;\n        u_xlatb7 = greaterThanEqual(vec4(_EmissionChannel), vec4(4.0, 3.0, 2.0, 1.0));\n        u_xlat16_8.xyz = u_xlat16_2.yyy * _EmissionColor.xyz;\n        u_xlat16_9.xyz = u_xlat16_2.xxx * _EmissionColor.xyz;\n        u_xlat16_8.xyz = (u_xlatb7.w) ? u_xlat16_8.xyz : u_xlat16_9.xyz;\n        u_xlat16_6.xyz = (u_xlatb7.z) ? u_xlat16_6.xyz : u_xlat16_8.xyz;\n        u_xlat16_5.xyz = (u_xlatb7.y) ? u_xlat16_5.xyz : u_xlat16_6.xyz;\n        u_xlat16_4.xyz = (u_xlatb7.x) ? u_xlat16_4.xyz : u_xlat16_5.xyz;\n    } else {\n        u_xlat16_4.xyz = _EmissionColor.xyz;\n    }\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_33 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_34 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_5.x = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_5.x = (-u_xlat16_34) + u_xlat16_5.x;\n    u_xlat16_33 = u_xlat16_33 + (-u_xlat16_34);\n    u_xlat16_34 = float(1.0) / u_xlat16_5.x;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_34;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_34 = u_xlat16_33 * -2.0 + 3.0;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_34;\n    u_xlat16_34 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_5.x = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_33 = u_xlat16_33 * _RampBands;\n    u_xlat16_15 = fract(u_xlat16_33);\n    u_xlat16_5.x = (-u_xlat16_34) + u_xlat16_5.x;\n    u_xlat16_34 = (-u_xlat16_34) + u_xlat16_15;\n    u_xlat16_5.x = float(1.0) / u_xlat16_5.x;\n    u_xlat16_34 = u_xlat16_34 * u_xlat16_5.x;\n    u_xlat16_34 = clamp(u_xlat16_34, 0.0, 1.0);\n    u_xlat16_5.x = u_xlat16_34 * -2.0 + 3.0;\n    u_xlat16_34 = u_xlat16_34 * u_xlat16_34;\n    u_xlat16_33 = floor(u_xlat16_33);\n    u_xlat16_33 = u_xlat16_5.x * u_xlat16_34 + u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 / _RampBands;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_5.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_5.xyz = vec3(u_xlat16_33) * u_xlat16_5.xyz + _SColor.xyz;\n    u_xlat16_5.xyz = u_xlat16_5.xyz * _LightColor0.xyz;\n    SV_Target0.xyz = u_xlat16_3.xyz * u_xlat16_5.xyz + u_xlat16_4.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tvec4 _EmissionMap_ST;\nuniform \tmediump float _EmissionChannel;\nuniform \tmediump vec4 _EmissionColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _EmissionMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec4 u_xlat0;\nvec3 u_xlat1;\nbvec2 u_xlatb1;\nmediump vec3 u_xlat16_2;\nvec2 u_xlat3;\nlowp vec4 u_xlat10_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nbvec4 u_xlatb8;\nmediump vec3 u_xlat16_9;\nmediump vec3 u_xlat16_10;\nfloat u_xlat33;\nbool u_xlatb33;\nmediump float u_xlat16_35;\nmediump float u_xlat16_37;\nmediump float u_xlat16_38;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat33 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat33) * u_xlat0.xyz;\n    u_xlat1.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_2.x = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat33 = max(u_xlat16_2.x, 0.00100000005);\n    u_xlat16_2.x = inversesqrt(u_xlat33);\n    u_xlat16_2.xyz = u_xlat1.xyz * u_xlat16_2.xxx;\n    u_xlat33 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat33 = inversesqrt(u_xlat33);\n    u_xlat1.xyz = vec3(u_xlat33) * _WorldSpaceLightPos0.xyz;\n    u_xlat10_3.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat10_3.xyz * _BaseColor.xyz;\n    u_xlatb33 = _EmissionChannel<5.0;\n    if(u_xlatb33){\n        u_xlat3.xy = vs_TEXCOORD1.zw * _EmissionMap_ST.xy + _EmissionMap_ST.zw;\n        u_xlat10_3 = texture2D(_EmissionMap, u_xlat3.xy);\n        u_xlat16_5.xyz = u_xlat10_3.xyz * _EmissionColor.xyz;\n        u_xlat16_6.xyz = u_xlat10_3.www * _EmissionColor.xyz;\n        u_xlat16_7.xyz = u_xlat10_3.zzz * _EmissionColor.xyz;\n        u_xlatb8 = greaterThanEqual(vec4(_EmissionChannel), vec4(4.0, 3.0, 2.0, 1.0));\n        u_xlat16_9.xyz = u_xlat10_3.yyy * _EmissionColor.xyz;\n        u_xlat16_10.xyz = u_xlat10_3.xxx * _EmissionColor.xyz;\n        u_xlat16_9.xyz = (u_xlatb8.w) ? u_xlat16_9.xyz : u_xlat16_10.xyz;\n        u_xlat16_7.xyz = (u_xlatb8.z) ? u_xlat16_7.xyz : u_xlat16_9.xyz;\n        u_xlat16_6.xyz = (u_xlatb8.y) ? u_xlat16_6.xyz : u_xlat16_7.xyz;\n        u_xlat16_5.xyz = (u_xlatb8.x) ? u_xlat16_5.xyz : u_xlat16_6.xyz;\n    } else {\n        u_xlat16_5.xyz = _EmissionColor.xyz;\n    }\n    u_xlat33 = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_35 = u_xlat33 * 0.5 + 0.5;\n    u_xlat16_37 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_38 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_38 = (-u_xlat16_37) + u_xlat16_38;\n    u_xlat16_35 = u_xlat16_35 + (-u_xlat16_37);\n    u_xlat16_37 = float(1.0) / u_xlat16_38;\n    u_xlat16_35 = u_xlat16_35 * u_xlat16_37;\n    u_xlat16_35 = clamp(u_xlat16_35, 0.0, 1.0);\n    u_xlat16_37 = u_xlat16_35 * -2.0 + 3.0;\n    u_xlat16_35 = u_xlat16_35 * u_xlat16_35;\n    u_xlat16_35 = u_xlat16_35 * u_xlat16_37;\n    u_xlat16_37 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_38 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_35 = u_xlat16_35 * _RampBands;\n    u_xlat16_6.x = fract(u_xlat16_35);\n    u_xlat16_38 = (-u_xlat16_37) + u_xlat16_38;\n    u_xlat16_37 = (-u_xlat16_37) + u_xlat16_6.x;\n    u_xlat16_38 = float(1.0) / u_xlat16_38;\n    u_xlat16_37 = u_xlat16_37 * u_xlat16_38;\n    u_xlat16_37 = clamp(u_xlat16_37, 0.0, 1.0);\n    u_xlat16_38 = u_xlat16_37 * -2.0 + 3.0;\n    u_xlat16_37 = u_xlat16_37 * u_xlat16_37;\n    u_xlat16_35 = floor(u_xlat16_35);\n    u_xlat16_35 = u_xlat16_38 * u_xlat16_37 + u_xlat16_35;\n    u_xlat16_35 = u_xlat16_35 / _RampBands;\n    u_xlat16_35 = clamp(u_xlat16_35, 0.0, 1.0);\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_6.xyz = vec3(u_xlat16_35) * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_6.xyz = u_xlat16_6.xyz * _LightColor0.xyz;\n    u_xlat16_6.xyz = u_xlat16_4.xyz * u_xlat16_6.xyz;\n    u_xlatb1.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat0.xyz = (u_xlatb1.x) ? u_xlat16_2.xyz : u_xlat0.xyz;\n    u_xlat0.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat0);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat0);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat0);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_6.xyz;\n    u_xlat16_2.xyz = (u_xlatb1.y) ? u_xlat16_2.xyz : u_xlat16_6.xyz;\n    SV_Target0.xyz = u_xlat16_5.xyz + u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tvec4 _EmissionMap_ST;\nuniform \tmediump float _EmissionChannel;\nuniform \tmediump vec4 _EmissionColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _EmissionMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec4 u_xlat0;\nvec3 u_xlat1;\nbvec2 u_xlatb1;\nmediump vec3 u_xlat16_2;\nvec2 u_xlat3;\nmediump vec4 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nbvec4 u_xlatb8;\nmediump vec3 u_xlat16_9;\nmediump vec3 u_xlat16_10;\nfloat u_xlat33;\nbool u_xlatb33;\nmediump float u_xlat16_35;\nmediump float u_xlat16_37;\nmediump float u_xlat16_38;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat33 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat33) * u_xlat0.xyz;\n    u_xlat1.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_2.x = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat33 = max(u_xlat16_2.x, 0.00100000005);\n    u_xlat16_2.x = inversesqrt(u_xlat33);\n    u_xlat16_2.xyz = u_xlat1.xyz * u_xlat16_2.xxx;\n    u_xlat33 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat33 = inversesqrt(u_xlat33);\n    u_xlat1.xyz = vec3(u_xlat33) * _WorldSpaceLightPos0.xyz;\n    u_xlat16_3.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat16_3.xyz * _BaseColor.xyz;\n    u_xlatb33 = _EmissionChannel<5.0;\n    if(u_xlatb33){\n        u_xlat3.xy = vs_TEXCOORD1.zw * _EmissionMap_ST.xy + _EmissionMap_ST.zw;\n        u_xlat16_3 = texture(_EmissionMap, u_xlat3.xy);\n        u_xlat16_5.xyz = u_xlat16_3.xyz * _EmissionColor.xyz;\n        u_xlat16_6.xyz = u_xlat16_3.www * _EmissionColor.xyz;\n        u_xlat16_7.xyz = u_xlat16_3.zzz * _EmissionColor.xyz;\n        u_xlatb8 = greaterThanEqual(vec4(_EmissionChannel), vec4(4.0, 3.0, 2.0, 1.0));\n        u_xlat16_9.xyz = u_xlat16_3.yyy * _EmissionColor.xyz;\n        u_xlat16_10.xyz = u_xlat16_3.xxx * _EmissionColor.xyz;\n        u_xlat16_9.xyz = (u_xlatb8.w) ? u_xlat16_9.xyz : u_xlat16_10.xyz;\n        u_xlat16_7.xyz = (u_xlatb8.z) ? u_xlat16_7.xyz : u_xlat16_9.xyz;\n        u_xlat16_6.xyz = (u_xlatb8.y) ? u_xlat16_6.xyz : u_xlat16_7.xyz;\n        u_xlat16_5.xyz = (u_xlatb8.x) ? u_xlat16_5.xyz : u_xlat16_6.xyz;\n    } else {\n        u_xlat16_5.xyz = _EmissionColor.xyz;\n    }\n    u_xlat33 = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_35 = u_xlat33 * 0.5 + 0.5;\n    u_xlat16_37 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_38 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_38 = (-u_xlat16_37) + u_xlat16_38;\n    u_xlat16_35 = u_xlat16_35 + (-u_xlat16_37);\n    u_xlat16_37 = float(1.0) / u_xlat16_38;\n    u_xlat16_35 = u_xlat16_35 * u_xlat16_37;\n    u_xlat16_35 = clamp(u_xlat16_35, 0.0, 1.0);\n    u_xlat16_37 = u_xlat16_35 * -2.0 + 3.0;\n    u_xlat16_35 = u_xlat16_35 * u_xlat16_35;\n    u_xlat16_35 = u_xlat16_35 * u_xlat16_37;\n    u_xlat16_37 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_38 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_35 = u_xlat16_35 * _RampBands;\n    u_xlat16_6.x = fract(u_xlat16_35);\n    u_xlat16_38 = (-u_xlat16_37) + u_xlat16_38;\n    u_xlat16_37 = (-u_xlat16_37) + u_xlat16_6.x;\n    u_xlat16_38 = float(1.0) / u_xlat16_38;\n    u_xlat16_37 = u_xlat16_37 * u_xlat16_38;\n    u_xlat16_37 = clamp(u_xlat16_37, 0.0, 1.0);\n    u_xlat16_38 = u_xlat16_37 * -2.0 + 3.0;\n    u_xlat16_37 = u_xlat16_37 * u_xlat16_37;\n    u_xlat16_35 = floor(u_xlat16_35);\n    u_xlat16_35 = u_xlat16_38 * u_xlat16_37 + u_xlat16_35;\n    u_xlat16_35 = u_xlat16_35 / _RampBands;\n    u_xlat16_35 = clamp(u_xlat16_35, 0.0, 1.0);\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_6.xyz = vec3(u_xlat16_35) * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_6.xyz = u_xlat16_6.xyz * _LightColor0.xyz;\n    u_xlat16_6.xyz = u_xlat16_4.xyz * u_xlat16_6.xyz;\n    u_xlatb1.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat0.xyz = (u_xlatb1.x) ? u_xlat16_2.xyz : u_xlat0.xyz;\n    u_xlat0.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat0);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat0);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat0);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_6.xyz;\n    u_xlat16_2.xyz = (u_xlatb1.y) ? u_xlat16_2.xyz : u_xlat16_6.xyz;\n    SV_Target0.xyz = u_xlat16_5.xyz + u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tvec4 _EmissionMap_ST;\nuniform \tmediump float _EmissionChannel;\nuniform \tmediump vec4 _EmissionColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nuniform lowp sampler2D _EmissionMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec4 u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nvec2 u_xlat3;\nlowp vec3 u_xlat10_3;\nbvec4 u_xlatb3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nmediump vec3 u_xlat16_8;\nmediump vec3 u_xlat16_9;\nmediump vec3 u_xlat16_10;\nmediump vec3 u_xlat16_16;\nfloat u_xlat33;\nmediump float u_xlat16_35;\nmediump float u_xlat16_37;\nmediump float u_xlat16_38;\nmediump float u_xlat16_39;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat33 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat33) * u_xlat0.xyz;\n    u_xlat1.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_2.x = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat33 = max(u_xlat16_2.x, 0.00100000005);\n    u_xlat16_2.x = inversesqrt(u_xlat33);\n    u_xlat16_2.xyz = u_xlat1.xyz * u_xlat16_2.xxx;\n    u_xlat33 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat33 = inversesqrt(u_xlat33);\n    u_xlat1.xyz = vec3(u_xlat33) * _WorldSpaceLightPos0.xyz;\n    u_xlat10_3.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat10_3.xyz * _BaseColor.xyz;\n    u_xlat3.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_3.xy = texture2D(_BumpMap, u_xlat3.xy).yw;\n    u_xlat16_5.xy = u_xlat10_3.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_35 = dot(u_xlat16_5.xy, u_xlat16_5.xy);\n    u_xlat16_35 = min(u_xlat16_35, 1.0);\n    u_xlat16_35 = (-u_xlat16_35) + 1.0;\n    u_xlat16_35 = sqrt(u_xlat16_35);\n    u_xlat16_5.xy = u_xlat16_5.xy * vec2(_BumpScale);\n    u_xlat16_16.xyz = u_xlat16_5.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_5.xyz = u_xlat16_5.xxx * vs_TEXCOORD2.xyz + u_xlat16_16.xyz;\n    u_xlat16_5.xyz = vec3(u_xlat16_35) * u_xlat0.xyz + u_xlat16_5.xyz;\n    u_xlatb0.x = _EmissionChannel<5.0;\n    if(u_xlatb0.x){\n        u_xlat0.xy = vs_TEXCOORD1.zw * _EmissionMap_ST.xy + _EmissionMap_ST.zw;\n        u_xlat10_0 = texture2D(_EmissionMap, u_xlat0.xy);\n        u_xlat16_6.xyz = u_xlat10_0.xyz * _EmissionColor.xyz;\n        u_xlat16_7.xyz = u_xlat10_0.www * _EmissionColor.xyz;\n        u_xlat16_8.xyz = u_xlat10_0.zzz * _EmissionColor.xyz;\n        u_xlatb3 = greaterThanEqual(vec4(_EmissionChannel), vec4(4.0, 3.0, 2.0, 1.0));\n        u_xlat16_9.xyz = u_xlat10_0.yyy * _EmissionColor.xyz;\n        u_xlat16_10.xyz = u_xlat10_0.xxx * _EmissionColor.xyz;\n        u_xlat16_9.xyz = (u_xlatb3.w) ? u_xlat16_9.xyz : u_xlat16_10.xyz;\n        u_xlat16_8.xyz = (u_xlatb3.z) ? u_xlat16_8.xyz : u_xlat16_9.xyz;\n        u_xlat16_7.xyz = (u_xlatb3.y) ? u_xlat16_7.xyz : u_xlat16_8.xyz;\n        u_xlat16_6.xyz = (u_xlatb3.x) ? u_xlat16_6.xyz : u_xlat16_7.xyz;\n    } else {\n        u_xlat16_6.xyz = _EmissionColor.xyz;\n    }\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat1.xyz);\n    u_xlat16_35 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_37 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_38 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_38 = (-u_xlat16_37) + u_xlat16_38;\n    u_xlat16_35 = u_xlat16_35 + (-u_xlat16_37);\n    u_xlat16_37 = float(1.0) / u_xlat16_38;\n    u_xlat16_35 = u_xlat16_35 * u_xlat16_37;\n    u_xlat16_35 = clamp(u_xlat16_35, 0.0, 1.0);\n    u_xlat16_37 = u_xlat16_35 * -2.0 + 3.0;\n    u_xlat16_35 = u_xlat16_35 * u_xlat16_35;\n    u_xlat16_35 = u_xlat16_35 * u_xlat16_37;\n    u_xlat16_37 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_38 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_35 = u_xlat16_35 * _RampBands;\n    u_xlat16_39 = fract(u_xlat16_35);\n    u_xlat16_38 = (-u_xlat16_37) + u_xlat16_38;\n    u_xlat16_37 = (-u_xlat16_37) + u_xlat16_39;\n    u_xlat16_38 = float(1.0) / u_xlat16_38;\n    u_xlat16_37 = u_xlat16_37 * u_xlat16_38;\n    u_xlat16_37 = clamp(u_xlat16_37, 0.0, 1.0);\n    u_xlat16_38 = u_xlat16_37 * -2.0 + 3.0;\n    u_xlat16_37 = u_xlat16_37 * u_xlat16_37;\n    u_xlat16_35 = floor(u_xlat16_35);\n    u_xlat16_35 = u_xlat16_38 * u_xlat16_37 + u_xlat16_35;\n    u_xlat16_35 = u_xlat16_35 / _RampBands;\n    u_xlat16_35 = clamp(u_xlat16_35, 0.0, 1.0);\n    u_xlat16_7.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_7.xyz = vec3(u_xlat16_35) * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat16_7.xyz = u_xlat16_7.xyz * _LightColor0.xyz;\n    u_xlat16_7.xyz = u_xlat16_4.xyz * u_xlat16_7.xyz;\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_2.xyz : u_xlat16_5.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_7.xyz;\n    u_xlat16_2.xyz = (u_xlatb0.y) ? u_xlat16_2.xyz : u_xlat16_7.xyz;\n    SV_Target0.xyz = u_xlat16_6.xyz + u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tvec4 _EmissionMap_ST;\nuniform \tmediump float _EmissionChannel;\nuniform \tmediump vec4 _EmissionColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nUNITY_LOCATION(2) uniform mediump sampler2D _EmissionMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec4 u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nvec2 u_xlat3;\nmediump vec3 u_xlat16_3;\nbvec4 u_xlatb3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nmediump vec3 u_xlat16_8;\nmediump vec3 u_xlat16_9;\nmediump vec3 u_xlat16_10;\nmediump vec3 u_xlat16_16;\nfloat u_xlat33;\nmediump float u_xlat16_35;\nmediump float u_xlat16_37;\nmediump float u_xlat16_38;\nmediump float u_xlat16_39;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat33 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat33) * u_xlat0.xyz;\n    u_xlat1.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_2.x = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat33 = max(u_xlat16_2.x, 0.00100000005);\n    u_xlat16_2.x = inversesqrt(u_xlat33);\n    u_xlat16_2.xyz = u_xlat1.xyz * u_xlat16_2.xxx;\n    u_xlat33 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat33 = inversesqrt(u_xlat33);\n    u_xlat1.xyz = vec3(u_xlat33) * _WorldSpaceLightPos0.xyz;\n    u_xlat16_3.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat16_3.xyz * _BaseColor.xyz;\n    u_xlat3.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_3.xy = texture(_BumpMap, u_xlat3.xy).yw;\n    u_xlat16_5.xy = u_xlat16_3.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_35 = dot(u_xlat16_5.xy, u_xlat16_5.xy);\n    u_xlat16_35 = min(u_xlat16_35, 1.0);\n    u_xlat16_35 = (-u_xlat16_35) + 1.0;\n    u_xlat16_35 = sqrt(u_xlat16_35);\n    u_xlat16_5.xy = u_xlat16_5.xy * vec2(_BumpScale);\n    u_xlat16_16.xyz = u_xlat16_5.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_5.xyz = u_xlat16_5.xxx * vs_TEXCOORD2.xyz + u_xlat16_16.xyz;\n    u_xlat16_5.xyz = vec3(u_xlat16_35) * u_xlat0.xyz + u_xlat16_5.xyz;\n    u_xlatb0.x = _EmissionChannel<5.0;\n    if(u_xlatb0.x){\n        u_xlat0.xy = vs_TEXCOORD1.zw * _EmissionMap_ST.xy + _EmissionMap_ST.zw;\n        u_xlat16_0 = texture(_EmissionMap, u_xlat0.xy);\n        u_xlat16_6.xyz = u_xlat16_0.xyz * _EmissionColor.xyz;\n        u_xlat16_7.xyz = u_xlat16_0.www * _EmissionColor.xyz;\n        u_xlat16_8.xyz = u_xlat16_0.zzz * _EmissionColor.xyz;\n        u_xlatb3 = greaterThanEqual(vec4(_EmissionChannel), vec4(4.0, 3.0, 2.0, 1.0));\n        u_xlat16_9.xyz = u_xlat16_0.yyy * _EmissionColor.xyz;\n        u_xlat16_10.xyz = u_xlat16_0.xxx * _EmissionColor.xyz;\n        u_xlat16_9.xyz = (u_xlatb3.w) ? u_xlat16_9.xyz : u_xlat16_10.xyz;\n        u_xlat16_8.xyz = (u_xlatb3.z) ? u_xlat16_8.xyz : u_xlat16_9.xyz;\n        u_xlat16_7.xyz = (u_xlatb3.y) ? u_xlat16_7.xyz : u_xlat16_8.xyz;\n        u_xlat16_6.xyz = (u_xlatb3.x) ? u_xlat16_6.xyz : u_xlat16_7.xyz;\n    } else {\n        u_xlat16_6.xyz = _EmissionColor.xyz;\n    }\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat1.xyz);\n    u_xlat16_35 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_37 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_38 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_38 = (-u_xlat16_37) + u_xlat16_38;\n    u_xlat16_35 = u_xlat16_35 + (-u_xlat16_37);\n    u_xlat16_37 = float(1.0) / u_xlat16_38;\n    u_xlat16_35 = u_xlat16_35 * u_xlat16_37;\n    u_xlat16_35 = clamp(u_xlat16_35, 0.0, 1.0);\n    u_xlat16_37 = u_xlat16_35 * -2.0 + 3.0;\n    u_xlat16_35 = u_xlat16_35 * u_xlat16_35;\n    u_xlat16_35 = u_xlat16_35 * u_xlat16_37;\n    u_xlat16_37 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_38 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_35 = u_xlat16_35 * _RampBands;\n    u_xlat16_39 = fract(u_xlat16_35);\n    u_xlat16_38 = (-u_xlat16_37) + u_xlat16_38;\n    u_xlat16_37 = (-u_xlat16_37) + u_xlat16_39;\n    u_xlat16_38 = float(1.0) / u_xlat16_38;\n    u_xlat16_37 = u_xlat16_37 * u_xlat16_38;\n    u_xlat16_37 = clamp(u_xlat16_37, 0.0, 1.0);\n    u_xlat16_38 = u_xlat16_37 * -2.0 + 3.0;\n    u_xlat16_37 = u_xlat16_37 * u_xlat16_37;\n    u_xlat16_35 = floor(u_xlat16_35);\n    u_xlat16_35 = u_xlat16_38 * u_xlat16_37 + u_xlat16_35;\n    u_xlat16_35 = u_xlat16_35 / _RampBands;\n    u_xlat16_35 = clamp(u_xlat16_35, 0.0, 1.0);\n    u_xlat16_7.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_7.xyz = vec3(u_xlat16_35) * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat16_7.xyz = u_xlat16_7.xyz * _LightColor0.xyz;\n    u_xlat16_7.xyz = u_xlat16_4.xyz * u_xlat16_7.xyz;\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_2.xyz : u_xlat16_5.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_7.xyz;\n    u_xlat16_2.xyz = (u_xlatb0.y) ? u_xlat16_2.xyz : u_xlat16_7.xyz;\n    SV_Target0.xyz = u_xlat16_6.xyz + u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tvec4 _EmissionMap_ST;\nuniform \tmediump float _EmissionChannel;\nuniform \tmediump vec4 _EmissionColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nuniform lowp sampler2D _EmissionMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec4 u_xlat10_0;\nbool u_xlatb0;\nvec3 u_xlat1;\nvec2 u_xlat2;\nlowp vec3 u_xlat10_2;\nbvec4 u_xlatb2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nmediump vec3 u_xlat16_8;\nmediump vec3 u_xlat16_9;\nmediump vec3 u_xlat16_14;\nmediump float u_xlat16_24;\nfloat u_xlat30;\nmediump float u_xlat16_33;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat30 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat30) * u_xlat0.xyz;\n    u_xlat30 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat30 = inversesqrt(u_xlat30);\n    u_xlat1.xyz = vec3(u_xlat30) * _WorldSpaceLightPos0.xyz;\n    u_xlat10_2.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_2.xyz * _BaseColor.xyz;\n    u_xlat2.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_2.xy = texture2D(_BumpMap, u_xlat2.xy).yw;\n    u_xlat16_4.xy = u_xlat10_2.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_33 = dot(u_xlat16_4.xy, u_xlat16_4.xy);\n    u_xlat16_33 = min(u_xlat16_33, 1.0);\n    u_xlat16_33 = (-u_xlat16_33) + 1.0;\n    u_xlat16_33 = sqrt(u_xlat16_33);\n    u_xlat16_4.xy = u_xlat16_4.xy * vec2(_BumpScale);\n    u_xlat16_14.xyz = u_xlat16_4.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_4.xyz = u_xlat16_4.xxx * vs_TEXCOORD2.xyz + u_xlat16_14.xyz;\n    u_xlat16_4.xyz = vec3(u_xlat16_33) * u_xlat0.xyz + u_xlat16_4.xyz;\n    u_xlatb0 = _EmissionChannel<5.0;\n    if(u_xlatb0){\n        u_xlat0.xy = vs_TEXCOORD1.zw * _EmissionMap_ST.xy + _EmissionMap_ST.zw;\n        u_xlat10_0 = texture2D(_EmissionMap, u_xlat0.xy);\n        u_xlat16_5.xyz = u_xlat10_0.xyz * _EmissionColor.xyz;\n        u_xlat16_6.xyz = u_xlat10_0.www * _EmissionColor.xyz;\n        u_xlat16_7.xyz = u_xlat10_0.zzz * _EmissionColor.xyz;\n        u_xlatb2 = greaterThanEqual(vec4(_EmissionChannel), vec4(4.0, 3.0, 2.0, 1.0));\n        u_xlat16_8.xyz = u_xlat10_0.yyy * _EmissionColor.xyz;\n        u_xlat16_9.xyz = u_xlat10_0.xxx * _EmissionColor.xyz;\n        u_xlat16_8.xyz = (u_xlatb2.w) ? u_xlat16_8.xyz : u_xlat16_9.xyz;\n        u_xlat16_7.xyz = (u_xlatb2.z) ? u_xlat16_7.xyz : u_xlat16_8.xyz;\n        u_xlat16_6.xyz = (u_xlatb2.y) ? u_xlat16_6.xyz : u_xlat16_7.xyz;\n        u_xlat16_5.xyz = (u_xlatb2.x) ? u_xlat16_5.xyz : u_xlat16_6.xyz;\n    } else {\n        u_xlat16_5.xyz = _EmissionColor.xyz;\n    }\n    u_xlat0.x = dot(u_xlat16_4.xyz, u_xlat1.xyz);\n    u_xlat16_33 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_4.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_14.x = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_14.x = (-u_xlat16_4.x) + u_xlat16_14.x;\n    u_xlat16_33 = u_xlat16_33 + (-u_xlat16_4.x);\n    u_xlat16_4.x = float(1.0) / u_xlat16_14.x;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_4.x;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_4.x = u_xlat16_33 * -2.0 + 3.0;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_4.x;\n    u_xlat16_4.x = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_14.x = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_33 = u_xlat16_33 * _RampBands;\n    u_xlat16_24 = fract(u_xlat16_33);\n    u_xlat16_14.x = (-u_xlat16_4.x) + u_xlat16_14.x;\n    u_xlat16_4.x = (-u_xlat16_4.x) + u_xlat16_24;\n    u_xlat16_14.x = float(1.0) / u_xlat16_14.x;\n    u_xlat16_4.x = u_xlat16_14.x * u_xlat16_4.x;\n    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0, 1.0);\n    u_xlat16_14.x = u_xlat16_4.x * -2.0 + 3.0;\n    u_xlat16_4.x = u_xlat16_4.x * u_xlat16_4.x;\n    u_xlat16_33 = floor(u_xlat16_33);\n    u_xlat16_33 = u_xlat16_14.x * u_xlat16_4.x + u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 / _RampBands;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_4.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_4.xyz = vec3(u_xlat16_33) * u_xlat16_4.xyz + _SColor.xyz;\n    u_xlat16_4.xyz = u_xlat16_4.xyz * _LightColor0.xyz;\n    SV_Target0.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz + u_xlat16_5.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tvec4 _EmissionMap_ST;\nuniform \tmediump float _EmissionChannel;\nuniform \tmediump vec4 _EmissionColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nUNITY_LOCATION(2) uniform mediump sampler2D _EmissionMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec4 u_xlat16_0;\nbool u_xlatb0;\nvec3 u_xlat1;\nvec2 u_xlat2;\nmediump vec3 u_xlat16_2;\nbvec4 u_xlatb2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nmediump vec3 u_xlat16_8;\nmediump vec3 u_xlat16_9;\nmediump vec3 u_xlat16_14;\nmediump float u_xlat16_24;\nfloat u_xlat30;\nmediump float u_xlat16_33;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat30 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat30) * u_xlat0.xyz;\n    u_xlat30 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat30 = inversesqrt(u_xlat30);\n    u_xlat1.xyz = vec3(u_xlat30) * _WorldSpaceLightPos0.xyz;\n    u_xlat16_2.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_2.xyz * _BaseColor.xyz;\n    u_xlat2.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_2.xy = texture(_BumpMap, u_xlat2.xy).yw;\n    u_xlat16_4.xy = u_xlat16_2.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_33 = dot(u_xlat16_4.xy, u_xlat16_4.xy);\n    u_xlat16_33 = min(u_xlat16_33, 1.0);\n    u_xlat16_33 = (-u_xlat16_33) + 1.0;\n    u_xlat16_33 = sqrt(u_xlat16_33);\n    u_xlat16_4.xy = u_xlat16_4.xy * vec2(_BumpScale);\n    u_xlat16_14.xyz = u_xlat16_4.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_4.xyz = u_xlat16_4.xxx * vs_TEXCOORD2.xyz + u_xlat16_14.xyz;\n    u_xlat16_4.xyz = vec3(u_xlat16_33) * u_xlat0.xyz + u_xlat16_4.xyz;\n    u_xlatb0 = _EmissionChannel<5.0;\n    if(u_xlatb0){\n        u_xlat0.xy = vs_TEXCOORD1.zw * _EmissionMap_ST.xy + _EmissionMap_ST.zw;\n        u_xlat16_0 = texture(_EmissionMap, u_xlat0.xy);\n        u_xlat16_5.xyz = u_xlat16_0.xyz * _EmissionColor.xyz;\n        u_xlat16_6.xyz = u_xlat16_0.www * _EmissionColor.xyz;\n        u_xlat16_7.xyz = u_xlat16_0.zzz * _EmissionColor.xyz;\n        u_xlatb2 = greaterThanEqual(vec4(_EmissionChannel), vec4(4.0, 3.0, 2.0, 1.0));\n        u_xlat16_8.xyz = u_xlat16_0.yyy * _EmissionColor.xyz;\n        u_xlat16_9.xyz = u_xlat16_0.xxx * _EmissionColor.xyz;\n        u_xlat16_8.xyz = (u_xlatb2.w) ? u_xlat16_8.xyz : u_xlat16_9.xyz;\n        u_xlat16_7.xyz = (u_xlatb2.z) ? u_xlat16_7.xyz : u_xlat16_8.xyz;\n        u_xlat16_6.xyz = (u_xlatb2.y) ? u_xlat16_6.xyz : u_xlat16_7.xyz;\n        u_xlat16_5.xyz = (u_xlatb2.x) ? u_xlat16_5.xyz : u_xlat16_6.xyz;\n    } else {\n        u_xlat16_5.xyz = _EmissionColor.xyz;\n    }\n    u_xlat0.x = dot(u_xlat16_4.xyz, u_xlat1.xyz);\n    u_xlat16_33 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_4.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_14.x = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_14.x = (-u_xlat16_4.x) + u_xlat16_14.x;\n    u_xlat16_33 = u_xlat16_33 + (-u_xlat16_4.x);\n    u_xlat16_4.x = float(1.0) / u_xlat16_14.x;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_4.x;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_4.x = u_xlat16_33 * -2.0 + 3.0;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_4.x;\n    u_xlat16_4.x = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_14.x = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_33 = u_xlat16_33 * _RampBands;\n    u_xlat16_24 = fract(u_xlat16_33);\n    u_xlat16_14.x = (-u_xlat16_4.x) + u_xlat16_14.x;\n    u_xlat16_4.x = (-u_xlat16_4.x) + u_xlat16_24;\n    u_xlat16_14.x = float(1.0) / u_xlat16_14.x;\n    u_xlat16_4.x = u_xlat16_14.x * u_xlat16_4.x;\n    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0, 1.0);\n    u_xlat16_14.x = u_xlat16_4.x * -2.0 + 3.0;\n    u_xlat16_4.x = u_xlat16_4.x * u_xlat16_4.x;\n    u_xlat16_33 = floor(u_xlat16_33);\n    u_xlat16_33 = u_xlat16_14.x * u_xlat16_4.x + u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 / _RampBands;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_4.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_4.xyz = vec3(u_xlat16_33) * u_xlat16_4.xyz + _SColor.xyz;\n    u_xlat16_4.xyz = u_xlat16_4.xyz * _LightColor0.xyz;\n    SV_Target0.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz + u_xlat16_5.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_7;\nmediump float u_xlat16_12;\nfloat u_xlat15;\nmediump float u_xlat16_17;\nvoid main()\n{\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat15 = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat15 = inversesqrt(u_xlat15);\n    u_xlat1.xyz = vec3(u_xlat15) * vs_NORMAL0.xyz;\n    u_xlat15 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;\n    u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_7.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_7.x) + u_xlat16_2.x;\n    u_xlat16_12 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_7.x = (-u_xlat16_7.x) + u_xlat16_12;\n    u_xlat16_7.x = float(1.0) / u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_7.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_7.x;\n    u_xlat16_7.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_17 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat15 = max(u_xlat16_17, 0.00100000005);\n    u_xlat16_17 = inversesqrt(u_xlat15);\n    u_xlat16_4.xyz = u_xlat0.xyz * vec3(u_xlat16_17);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_4.xyz : u_xlat1.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_4.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_4.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_4.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_4.xyz = max(u_xlat16_4.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_2.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_3.xyz : u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_7;\nmediump float u_xlat16_12;\nfloat u_xlat15;\nmediump float u_xlat16_17;\nvoid main()\n{\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat15 = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat15 = inversesqrt(u_xlat15);\n    u_xlat1.xyz = vec3(u_xlat15) * vs_NORMAL0.xyz;\n    u_xlat15 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;\n    u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_7.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_7.x) + u_xlat16_2.x;\n    u_xlat16_12 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_7.x = (-u_xlat16_7.x) + u_xlat16_12;\n    u_xlat16_7.x = float(1.0) / u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_7.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_7.x;\n    u_xlat16_7.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_17 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat15 = max(u_xlat16_17, 0.00100000005);\n    u_xlat16_17 = inversesqrt(u_xlat15);\n    u_xlat16_4.xyz = u_xlat0.xyz * vec3(u_xlat16_17);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_4.xyz : u_xlat1.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_4.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_4.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_4.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_4.xyz = max(u_xlat16_4.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_2.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_3.xyz : u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump float u_xlat16_9;\nmediump float u_xlat16_14;\nfloat u_xlat18;\nmediump float u_xlat16_20;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat18 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_14 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_14 = min(u_xlat16_14, 1.0);\n    u_xlat16_14 = (-u_xlat16_14) + 1.0;\n    u_xlat16_14 = sqrt(u_xlat16_14);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_14) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_20 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_3.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_3.x);\n    u_xlat16_9 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_3.x = (-u_xlat16_3.x) + u_xlat16_9;\n    u_xlat16_3.x = float(1.0) / u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.x = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_3.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_3.xyz = vec3(u_xlat16_20) * u_xlat16_3.xyz + _SColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_20 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat18 = max(u_xlat16_20, 0.00100000005);\n    u_xlat16_20 = inversesqrt(u_xlat18);\n    u_xlat16_5.xyz = u_xlat0.xyz * vec3(u_xlat16_20);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_5.xyz : u_xlat16_2.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_3.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_2.xyz : u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump float u_xlat16_9;\nmediump float u_xlat16_14;\nfloat u_xlat18;\nmediump float u_xlat16_20;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat18 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_14 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_14 = min(u_xlat16_14, 1.0);\n    u_xlat16_14 = (-u_xlat16_14) + 1.0;\n    u_xlat16_14 = sqrt(u_xlat16_14);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_14) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_20 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_3.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_3.x);\n    u_xlat16_9 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_3.x = (-u_xlat16_3.x) + u_xlat16_9;\n    u_xlat16_3.x = float(1.0) / u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.x = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_3.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_3.xyz = vec3(u_xlat16_20) * u_xlat16_3.xyz + _SColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_20 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat18 = max(u_xlat16_20, 0.00100000005);\n    u_xlat16_20 = inversesqrt(u_xlat18);\n    u_xlat16_5.xyz = u_xlat0.xyz * vec3(u_xlat16_20);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_5.xyz : u_xlat16_2.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_3.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_2.xyz : u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec2 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec2 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6.x = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6.x = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_7;\nmediump float u_xlat16_12;\nfloat u_xlat15;\nmediump float u_xlat16_17;\nvoid main()\n{\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat15 = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat15 = inversesqrt(u_xlat15);\n    u_xlat1.xyz = vec3(u_xlat15) * vs_NORMAL0.xyz;\n    u_xlat15 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;\n    u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_7.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_7.x) + u_xlat16_2.x;\n    u_xlat16_12 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_7.x = (-u_xlat16_7.x) + u_xlat16_12;\n    u_xlat16_7.x = float(1.0) / u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_7.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_7.x = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_12 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_12) + u_xlat16_2.x;\n    u_xlat16_17 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_12 = (-u_xlat16_12) + u_xlat16_17;\n    u_xlat16_12 = float(1.0) / u_xlat16_12;\n    u_xlat16_2.x = u_xlat16_12 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_12 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_12 * u_xlat16_2.x + u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_17 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat15 = max(u_xlat16_17, 0.00100000005);\n    u_xlat16_17 = inversesqrt(u_xlat15);\n    u_xlat16_4.xyz = u_xlat0.xyz * vec3(u_xlat16_17);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_4.xyz : u_xlat1.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_4.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_4.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_4.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_4.xyz = max(u_xlat16_4.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_2.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_3.xyz : u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_7;\nmediump float u_xlat16_12;\nfloat u_xlat15;\nmediump float u_xlat16_17;\nvoid main()\n{\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat15 = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat15 = inversesqrt(u_xlat15);\n    u_xlat1.xyz = vec3(u_xlat15) * vs_NORMAL0.xyz;\n    u_xlat15 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;\n    u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_7.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_7.x) + u_xlat16_2.x;\n    u_xlat16_12 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_7.x = (-u_xlat16_7.x) + u_xlat16_12;\n    u_xlat16_7.x = float(1.0) / u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_7.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_7.x = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_12 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_12) + u_xlat16_2.x;\n    u_xlat16_17 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_12 = (-u_xlat16_12) + u_xlat16_17;\n    u_xlat16_12 = float(1.0) / u_xlat16_12;\n    u_xlat16_2.x = u_xlat16_12 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_12 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_12 * u_xlat16_2.x + u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_17 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat15 = max(u_xlat16_17, 0.00100000005);\n    u_xlat16_17 = inversesqrt(u_xlat15);\n    u_xlat16_4.xyz = u_xlat0.xyz * vec3(u_xlat16_17);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_4.xyz : u_xlat1.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_4.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_4.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_4.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_4.xyz = max(u_xlat16_4.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_2.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_3.xyz : u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump float u_xlat16_9;\nmediump float u_xlat16_14;\nmediump float u_xlat16_15;\nfloat u_xlat18;\nmediump float u_xlat16_20;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat18 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_14 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_14 = min(u_xlat16_14, 1.0);\n    u_xlat16_14 = (-u_xlat16_14) + 1.0;\n    u_xlat16_14 = sqrt(u_xlat16_14);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_14) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_20 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_3.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_3.x);\n    u_xlat16_9 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_3.x = (-u_xlat16_3.x) + u_xlat16_9;\n    u_xlat16_3.x = float(1.0) / u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.x = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * _RampBands;\n    u_xlat16_3.x = floor(u_xlat16_20);\n    u_xlat16_20 = fract(u_xlat16_20);\n    u_xlat16_9 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_9);\n    u_xlat16_15 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_9 = (-u_xlat16_9) + u_xlat16_15;\n    u_xlat16_9 = float(1.0) / u_xlat16_9;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_9;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_9 = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_9 * u_xlat16_20 + u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 / _RampBands;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_3.xyz = vec3(u_xlat16_20) * u_xlat16_3.xyz + _SColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_20 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat18 = max(u_xlat16_20, 0.00100000005);\n    u_xlat16_20 = inversesqrt(u_xlat18);\n    u_xlat16_5.xyz = u_xlat0.xyz * vec3(u_xlat16_20);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_5.xyz : u_xlat16_2.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_3.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_2.xyz : u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump float u_xlat16_9;\nmediump float u_xlat16_14;\nmediump float u_xlat16_15;\nfloat u_xlat18;\nmediump float u_xlat16_20;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat18 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_14 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_14 = min(u_xlat16_14, 1.0);\n    u_xlat16_14 = (-u_xlat16_14) + 1.0;\n    u_xlat16_14 = sqrt(u_xlat16_14);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_14) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_20 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_3.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_3.x);\n    u_xlat16_9 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_3.x = (-u_xlat16_3.x) + u_xlat16_9;\n    u_xlat16_3.x = float(1.0) / u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.x = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * _RampBands;\n    u_xlat16_3.x = floor(u_xlat16_20);\n    u_xlat16_20 = fract(u_xlat16_20);\n    u_xlat16_9 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_9);\n    u_xlat16_15 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_9 = (-u_xlat16_9) + u_xlat16_15;\n    u_xlat16_9 = float(1.0) / u_xlat16_9;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_9;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_9 = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_9 * u_xlat16_20 + u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 / _RampBands;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_3.xyz = vec3(u_xlat16_20) * u_xlat16_3.xyz + _SColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_20 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat18 = max(u_xlat16_20, 0.00100000005);\n    u_xlat16_20 = inversesqrt(u_xlat18);\n    u_xlat16_5.xyz = u_xlat0.xyz * vec3(u_xlat16_20);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_5.xyz : u_xlat16_2.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_3.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_2.xyz : u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec2 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6.x = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec2 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6.x = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_7;\nmediump float u_xlat16_12;\nfloat u_xlat15;\nmediump float u_xlat16_17;\nvoid main()\n{\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat15 = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat15 = inversesqrt(u_xlat15);\n    u_xlat1.xyz = vec3(u_xlat15) * vs_NORMAL0.xyz;\n    u_xlat15 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;\n    u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_7.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_7.x) + u_xlat16_2.x;\n    u_xlat16_12 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_7.x = (-u_xlat16_7.x) + u_xlat16_12;\n    u_xlat16_7.x = float(1.0) / u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_7.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_7.x;\n    u_xlat16_7.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_17 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat15 = max(u_xlat16_17, 0.00100000005);\n    u_xlat16_17 = inversesqrt(u_xlat15);\n    u_xlat16_4.xyz = u_xlat0.xyz * vec3(u_xlat16_17);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_4.xyz : u_xlat1.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_4.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_4.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_4.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_4.xyz = max(u_xlat16_4.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_2.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_3.xyz : u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_7;\nmediump float u_xlat16_12;\nfloat u_xlat15;\nmediump float u_xlat16_17;\nvoid main()\n{\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat15 = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat15 = inversesqrt(u_xlat15);\n    u_xlat1.xyz = vec3(u_xlat15) * vs_NORMAL0.xyz;\n    u_xlat15 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat1.xyz = vec3(u_xlat15) * u_xlat1.xyz;\n    u_xlat0.x = dot(u_xlat1.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_7.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_7.x) + u_xlat16_2.x;\n    u_xlat16_12 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_7.x = (-u_xlat16_7.x) + u_xlat16_12;\n    u_xlat16_7.x = float(1.0) / u_xlat16_7.x;\n    u_xlat16_2.x = u_xlat16_7.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_7.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_7.x;\n    u_xlat16_7.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_7.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_17 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat15 = max(u_xlat16_17, 0.00100000005);\n    u_xlat16_17 = inversesqrt(u_xlat15);\n    u_xlat16_4.xyz = u_xlat0.xyz * vec3(u_xlat16_17);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_4.xyz : u_xlat1.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_4.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_4.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_4.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_4.xyz = max(u_xlat16_4.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_2.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_3.xyz : u_xlat16_2.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump float u_xlat16_9;\nmediump float u_xlat16_14;\nfloat u_xlat18;\nmediump float u_xlat16_20;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat18 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_14 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_14 = min(u_xlat16_14, 1.0);\n    u_xlat16_14 = (-u_xlat16_14) + 1.0;\n    u_xlat16_14 = sqrt(u_xlat16_14);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_14) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_20 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_3.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_3.x);\n    u_xlat16_9 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_3.x = (-u_xlat16_3.x) + u_xlat16_9;\n    u_xlat16_3.x = float(1.0) / u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.x = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_3.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_3.xyz = vec3(u_xlat16_20) * u_xlat16_3.xyz + _SColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_20 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat18 = max(u_xlat16_20, 0.00100000005);\n    u_xlat16_20 = inversesqrt(u_xlat18);\n    u_xlat16_5.xyz = u_xlat0.xyz * vec3(u_xlat16_20);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_5.xyz : u_xlat16_2.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_3.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_2.xyz : u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump float u_xlat16_9;\nmediump float u_xlat16_14;\nfloat u_xlat18;\nmediump float u_xlat16_20;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat18 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat18) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_14 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_14 = min(u_xlat16_14, 1.0);\n    u_xlat16_14 = (-u_xlat16_14) + 1.0;\n    u_xlat16_14 = sqrt(u_xlat16_14);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_14) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_20 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_3.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_20 = u_xlat16_20 + (-u_xlat16_3.x);\n    u_xlat16_9 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_3.x = (-u_xlat16_3.x) + u_xlat16_9;\n    u_xlat16_3.x = float(1.0) / u_xlat16_3.x;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_20 = clamp(u_xlat16_20, 0.0, 1.0);\n    u_xlat16_3.x = u_xlat16_20 * -2.0 + 3.0;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_20;\n    u_xlat16_20 = u_xlat16_20 * u_xlat16_3.x;\n    u_xlat16_3.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_3.xyz = vec3(u_xlat16_20) * u_xlat16_3.xyz + _SColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_4.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    u_xlat16_3.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz;\n    u_xlat0.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_20 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat18 = max(u_xlat16_20, 0.00100000005);\n    u_xlat16_20 = inversesqrt(u_xlat18);\n    u_xlat16_5.xyz = u_xlat0.xyz * vec3(u_xlat16_20);\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_5.xyz : u_xlat16_2.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_2.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_2.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_2.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_2.xyz = max(u_xlat16_2.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_2.xyz = u_xlat16_4.xyz * u_xlat16_2.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_3.xyz;\n    SV_Target0.xyz = (u_xlatb0.y) ? u_xlat16_2.xyz : u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec2 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec2 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump vec4 _SpecularColor;\nuniform \tmediump float _SpecularMapType;\nuniform \tmediump float _SpecularToonSize;\nuniform \tmediump float _SpecularToonSmoothness;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nuniform lowp sampler2D _SpecGlossMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp float u_xlat10_0;\nbool u_xlatb0;\nvec3 u_xlat1;\nmediump float u_xlat16_2;\nvec3 u_xlat3;\nvec2 u_xlat4;\nlowp vec4 u_xlat10_4;\nmediump vec4 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nfloat u_xlat8;\nmediump vec3 u_xlat16_10;\nmediump float u_xlat16_13;\nmediump vec3 u_xlat16_14;\nmediump float u_xlat16_21;\nmediump float u_xlat16_22;\nfloat u_xlat24;\nmediump float u_xlat16_29;\nmediump float u_xlat16_30;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat24 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat24) * u_xlat0.xyz;\n    u_xlat1.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_2 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat24 = max(u_xlat16_2, 0.00100000005);\n    u_xlat16_2 = inversesqrt(u_xlat24);\n    u_xlat24 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat24 = inversesqrt(u_xlat24);\n    u_xlat3.xyz = vec3(u_xlat24) * _WorldSpaceLightPos0.xyz;\n    u_xlat10_4 = texture2D(_BaseMap, vs_TEXCOORD1.xy);\n    u_xlat16_10.xyz = u_xlat10_4.xyz * _BaseColor.xyz;\n    u_xlat4.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_4.xy = texture2D(_BumpMap, u_xlat4.xy).yw;\n    u_xlat16_5.xy = u_xlat10_4.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_21 = dot(u_xlat16_5.xy, u_xlat16_5.xy);\n    u_xlat16_21 = min(u_xlat16_21, 1.0);\n    u_xlat16_21 = (-u_xlat16_21) + 1.0;\n    u_xlat16_21 = sqrt(u_xlat16_21);\n    u_xlat16_5.xy = u_xlat16_5.xy * vec2(_BumpScale);\n    u_xlat16_6.xyz = u_xlat16_5.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_5.xyw = u_xlat16_5.xxx * vs_TEXCOORD2.xyz + u_xlat16_6.xyz;\n    u_xlat16_5.xyz = vec3(u_xlat16_21) * u_xlat0.xyz + u_xlat16_5.xyw;\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat3.xyz);\n    u_xlat16_29 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = u_xlat0.x;\n    u_xlat16_6.x = clamp(u_xlat16_6.x, 0.0, 1.0);\n    u_xlat16_14.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_22 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_22 = (-u_xlat16_14.x) + u_xlat16_22;\n    u_xlat16_29 = u_xlat16_29 + (-u_xlat16_14.x);\n    u_xlat16_14.x = float(1.0) / u_xlat16_22;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_14.x;\n    u_xlat16_29 = clamp(u_xlat16_29, 0.0, 1.0);\n    u_xlat16_14.x = u_xlat16_29 * -2.0 + 3.0;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_29;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_14.x;\n    u_xlat16_14.x = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_22 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_29 = u_xlat16_29 * _RampBands;\n    u_xlat16_30 = fract(u_xlat16_29);\n    u_xlat16_22 = (-u_xlat16_14.x) + u_xlat16_22;\n    u_xlat16_14.x = (-u_xlat16_14.x) + u_xlat16_30;\n    u_xlat16_22 = float(1.0) / u_xlat16_22;\n    u_xlat16_14.x = u_xlat16_22 * u_xlat16_14.x;\n    u_xlat16_14.x = clamp(u_xlat16_14.x, 0.0, 1.0);\n    u_xlat16_22 = u_xlat16_14.x * -2.0 + 3.0;\n    u_xlat16_14.x = u_xlat16_14.x * u_xlat16_14.x;\n    u_xlat16_29 = floor(u_xlat16_29);\n    u_xlat16_29 = u_xlat16_22 * u_xlat16_14.x + u_xlat16_29;\n    u_xlat16_29 = u_xlat16_29 / _RampBands;\n    u_xlat16_29 = clamp(u_xlat16_29, 0.0, 1.0);\n    u_xlat16_14.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_14.xyz = vec3(u_xlat16_29) * u_xlat16_14.xyz + _SColor.xyz;\n    u_xlat16_14.xyz = u_xlat16_14.xyz * _LightColor0.xyz;\n    u_xlatb0 = _SpecularMapType>=5.0;\n    if(u_xlatb0){\n        u_xlat10_0 = texture2D(_SpecGlossMap, vs_TEXCOORD1.xy).w;\n        u_xlat16_29 = u_xlat10_0;\n    } else {\n        u_xlatb0 = _SpecularMapType>=4.0;\n        if(u_xlatb0){\n            u_xlat10_0 = texture2D(_SpecGlossMap, vs_TEXCOORD1.xy).z;\n            u_xlat16_29 = u_xlat10_0;\n        } else {\n            u_xlatb0 = _SpecularMapType>=3.0;\n            if(u_xlatb0){\n                u_xlat10_0 = texture2D(_SpecGlossMap, vs_TEXCOORD1.xy).y;\n                u_xlat16_29 = u_xlat10_0;\n            } else {\n                u_xlatb0 = _SpecularMapType>=2.0;\n                if(u_xlatb0){\n                    u_xlat10_0 = texture2D(_SpecGlossMap, vs_TEXCOORD1.xy).x;\n                    u_xlat16_29 = u_xlat10_0;\n                } else {\n                    u_xlatb0 = _SpecularMapType>=1.0;\n                    u_xlat16_29 = (u_xlatb0) ? u_xlat10_4.w : 1.0;\n                }\n            }\n        }\n    }\n    u_xlat16_7.xyz = u_xlat1.xyz * vec3(u_xlat16_2) + u_xlat3.xyz;\n    u_xlat16_2 = dot(u_xlat16_7.xyz, u_xlat16_7.xyz);\n    u_xlat0.x = max(u_xlat16_2, 0.00100000005);\n    u_xlat16_2 = inversesqrt(u_xlat0.x);\n    u_xlat16_7.xyz = vec3(u_xlat16_2) * u_xlat16_7.xyz;\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat16_7.xyz);\n    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\n    u_xlat16_2 = (-_SpecularToonSize) * u_xlat16_29 + 1.0;\n    u_xlat16_5.x = (-u_xlat16_2) + 1.0;\n    u_xlat16_13 = float(1.0) / u_xlat16_5.x;\n    u_xlat16_2 = u_xlat16_2 / u_xlat16_5.x;\n    u_xlat16_2 = u_xlat0.x * u_xlat16_13 + (-u_xlat16_2);\n    u_xlat0.x = float(1.0) / _SpecularToonSmoothness;\n    u_xlat0.x = u_xlat0.x * u_xlat16_2;\n    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\n    u_xlat8 = u_xlat0.x * -2.0 + 3.0;\n    u_xlat0.x = u_xlat0.x * u_xlat0.x;\n    u_xlat0.x = u_xlat0.x * u_xlat8;\n    u_xlat16_2 = u_xlat16_6.x * u_xlat0.x;\n    u_xlat16_5.xyz = vec3(u_xlat16_2) * _LightColor0.xyz;\n    u_xlat16_5.xyz = u_xlat16_5.xyz * _SpecularColor.xyz;\n    SV_Target0.xyz = u_xlat16_10.xyz * u_xlat16_14.xyz + u_xlat16_5.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump vec4 _SpecularColor;\nuniform \tmediump float _SpecularMapType;\nuniform \tmediump float _SpecularToonSize;\nuniform \tmediump float _SpecularToonSmoothness;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nUNITY_LOCATION(2) uniform mediump sampler2D _SpecGlossMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump float u_xlat16_0;\nbool u_xlatb0;\nvec3 u_xlat1;\nmediump float u_xlat16_2;\nvec3 u_xlat3;\nvec2 u_xlat4;\nmediump vec4 u_xlat16_4;\nmediump vec4 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nfloat u_xlat8;\nmediump vec3 u_xlat16_10;\nmediump float u_xlat16_13;\nmediump vec3 u_xlat16_14;\nmediump float u_xlat16_21;\nmediump float u_xlat16_22;\nfloat u_xlat24;\nmediump float u_xlat16_29;\nmediump float u_xlat16_30;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat24 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat24) * u_xlat0.xyz;\n    u_xlat1.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_2 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat24 = max(u_xlat16_2, 0.00100000005);\n    u_xlat16_2 = inversesqrt(u_xlat24);\n    u_xlat24 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat24 = inversesqrt(u_xlat24);\n    u_xlat3.xyz = vec3(u_xlat24) * _WorldSpaceLightPos0.xyz;\n    u_xlat16_4 = texture(_BaseMap, vs_TEXCOORD1.xy);\n    u_xlat16_10.xyz = u_xlat16_4.xyz * _BaseColor.xyz;\n    u_xlat4.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_4.xy = texture(_BumpMap, u_xlat4.xy).yw;\n    u_xlat16_5.xy = u_xlat16_4.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_21 = dot(u_xlat16_5.xy, u_xlat16_5.xy);\n    u_xlat16_21 = min(u_xlat16_21, 1.0);\n    u_xlat16_21 = (-u_xlat16_21) + 1.0;\n    u_xlat16_21 = sqrt(u_xlat16_21);\n    u_xlat16_5.xy = u_xlat16_5.xy * vec2(_BumpScale);\n    u_xlat16_6.xyz = u_xlat16_5.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_5.xyw = u_xlat16_5.xxx * vs_TEXCOORD2.xyz + u_xlat16_6.xyz;\n    u_xlat16_5.xyz = vec3(u_xlat16_21) * u_xlat0.xyz + u_xlat16_5.xyw;\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat3.xyz);\n    u_xlat16_29 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = u_xlat0.x;\n    u_xlat16_6.x = clamp(u_xlat16_6.x, 0.0, 1.0);\n    u_xlat16_14.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_22 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_22 = (-u_xlat16_14.x) + u_xlat16_22;\n    u_xlat16_29 = u_xlat16_29 + (-u_xlat16_14.x);\n    u_xlat16_14.x = float(1.0) / u_xlat16_22;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_14.x;\n    u_xlat16_29 = clamp(u_xlat16_29, 0.0, 1.0);\n    u_xlat16_14.x = u_xlat16_29 * -2.0 + 3.0;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_29;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_14.x;\n    u_xlat16_14.x = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_22 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_29 = u_xlat16_29 * _RampBands;\n    u_xlat16_30 = fract(u_xlat16_29);\n    u_xlat16_22 = (-u_xlat16_14.x) + u_xlat16_22;\n    u_xlat16_14.x = (-u_xlat16_14.x) + u_xlat16_30;\n    u_xlat16_22 = float(1.0) / u_xlat16_22;\n    u_xlat16_14.x = u_xlat16_22 * u_xlat16_14.x;\n    u_xlat16_14.x = clamp(u_xlat16_14.x, 0.0, 1.0);\n    u_xlat16_22 = u_xlat16_14.x * -2.0 + 3.0;\n    u_xlat16_14.x = u_xlat16_14.x * u_xlat16_14.x;\n    u_xlat16_29 = floor(u_xlat16_29);\n    u_xlat16_29 = u_xlat16_22 * u_xlat16_14.x + u_xlat16_29;\n    u_xlat16_29 = u_xlat16_29 / _RampBands;\n    u_xlat16_29 = clamp(u_xlat16_29, 0.0, 1.0);\n    u_xlat16_14.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_14.xyz = vec3(u_xlat16_29) * u_xlat16_14.xyz + _SColor.xyz;\n    u_xlat16_14.xyz = u_xlat16_14.xyz * _LightColor0.xyz;\n    u_xlatb0 = _SpecularMapType>=5.0;\n    if(u_xlatb0){\n        u_xlat16_0 = texture(_SpecGlossMap, vs_TEXCOORD1.xy).w;\n        u_xlat16_29 = u_xlat16_0;\n    } else {\n        u_xlatb0 = _SpecularMapType>=4.0;\n        if(u_xlatb0){\n            u_xlat16_0 = texture(_SpecGlossMap, vs_TEXCOORD1.xy).z;\n            u_xlat16_29 = u_xlat16_0;\n        } else {\n            u_xlatb0 = _SpecularMapType>=3.0;\n            if(u_xlatb0){\n                u_xlat16_0 = texture(_SpecGlossMap, vs_TEXCOORD1.xy).y;\n                u_xlat16_29 = u_xlat16_0;\n            } else {\n                u_xlatb0 = _SpecularMapType>=2.0;\n                if(u_xlatb0){\n                    u_xlat16_0 = texture(_SpecGlossMap, vs_TEXCOORD1.xy).x;\n                    u_xlat16_29 = u_xlat16_0;\n                } else {\n                    u_xlatb0 = _SpecularMapType>=1.0;\n                    u_xlat16_29 = (u_xlatb0) ? u_xlat16_4.w : 1.0;\n                }\n            }\n        }\n    }\n    u_xlat16_7.xyz = u_xlat1.xyz * vec3(u_xlat16_2) + u_xlat3.xyz;\n    u_xlat16_2 = dot(u_xlat16_7.xyz, u_xlat16_7.xyz);\n    u_xlat0.x = max(u_xlat16_2, 0.00100000005);\n    u_xlat16_2 = inversesqrt(u_xlat0.x);\n    u_xlat16_7.xyz = vec3(u_xlat16_2) * u_xlat16_7.xyz;\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat16_7.xyz);\n    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\n    u_xlat16_2 = (-_SpecularToonSize) * u_xlat16_29 + 1.0;\n    u_xlat16_5.x = (-u_xlat16_2) + 1.0;\n    u_xlat16_13 = float(1.0) / u_xlat16_5.x;\n    u_xlat16_2 = u_xlat16_2 / u_xlat16_5.x;\n    u_xlat16_2 = u_xlat0.x * u_xlat16_13 + (-u_xlat16_2);\n    u_xlat0.x = float(1.0) / _SpecularToonSmoothness;\n    u_xlat0.x = u_xlat0.x * u_xlat16_2;\n    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\n    u_xlat8 = u_xlat0.x * -2.0 + 3.0;\n    u_xlat0.x = u_xlat0.x * u_xlat0.x;\n    u_xlat0.x = u_xlat0.x * u_xlat8;\n    u_xlat16_2 = u_xlat16_6.x * u_xlat0.x;\n    u_xlat16_5.xyz = vec3(u_xlat16_2) * _LightColor0.xyz;\n    u_xlat16_5.xyz = u_xlat16_5.xyz * _SpecularColor.xyz;\n    SV_Target0.xyz = u_xlat16_10.xyz * u_xlat16_14.xyz + u_xlat16_5.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump vec4 _SpecularColor;\nuniform \tmediump float _SpecularMapType;\nuniform \tmediump float _SpecularToonSize;\nuniform \tmediump float _SpecularToonSmoothness;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nuniform lowp sampler2D _SpecGlossMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp float u_xlat10_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nvec2 u_xlat3;\nlowp vec4 u_xlat10_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nfloat u_xlat8;\nmediump float u_xlat16_10;\nmediump vec3 u_xlat16_13;\nmediump float u_xlat16_14;\nmediump float u_xlat16_18;\nfloat u_xlat24;\nmediump float u_xlat16_26;\nmediump float u_xlat16_28;\nmediump float u_xlat16_29;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat24 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat24) * u_xlat0.xyz;\n    u_xlat1.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_2.x = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat24 = max(u_xlat16_2.x, 0.00100000005);\n    u_xlat16_2.x = inversesqrt(u_xlat24);\n    u_xlat16_2.xyz = u_xlat1.xyz * u_xlat16_2.xxx;\n    u_xlat24 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat24 = inversesqrt(u_xlat24);\n    u_xlat1.xyz = vec3(u_xlat24) * _WorldSpaceLightPos0.xyz;\n    u_xlat10_3 = texture2D(_BaseMap, vs_TEXCOORD1.xy);\n    u_xlat16_4.xyz = u_xlat10_3.xyz * _BaseColor.xyz;\n    u_xlat3.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_3.xy = texture2D(_BumpMap, u_xlat3.xy).yw;\n    u_xlat16_5.xy = u_xlat10_3.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_26 = dot(u_xlat16_5.xy, u_xlat16_5.xy);\n    u_xlat16_26 = min(u_xlat16_26, 1.0);\n    u_xlat16_26 = (-u_xlat16_26) + 1.0;\n    u_xlat16_26 = sqrt(u_xlat16_26);\n    u_xlat16_5.xy = u_xlat16_5.xy * vec2(_BumpScale);\n    u_xlat16_13.xyz = u_xlat16_5.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_5.xyz = u_xlat16_5.xxx * vs_TEXCOORD2.xyz + u_xlat16_13.xyz;\n    u_xlat16_5.xyz = vec3(u_xlat16_26) * u_xlat0.xyz + u_xlat16_5.xyz;\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat1.xyz);\n    u_xlat16_26 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_28 = u_xlat0.x;\n    u_xlat16_28 = clamp(u_xlat16_28, 0.0, 1.0);\n    u_xlat16_29 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_6.x = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_29) + u_xlat16_6.x;\n    u_xlat16_26 = u_xlat16_26 + (-u_xlat16_29);\n    u_xlat16_29 = float(1.0) / u_xlat16_6.x;\n    u_xlat16_26 = u_xlat16_26 * u_xlat16_29;\n    u_xlat16_26 = clamp(u_xlat16_26, 0.0, 1.0);\n    u_xlat16_29 = u_xlat16_26 * -2.0 + 3.0;\n    u_xlat16_26 = u_xlat16_26 * u_xlat16_26;\n    u_xlat16_26 = u_xlat16_26 * u_xlat16_29;\n    u_xlat16_29 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_6.x = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_26 = u_xlat16_26 * _RampBands;\n    u_xlat16_14 = fract(u_xlat16_26);\n    u_xlat16_6.x = (-u_xlat16_29) + u_xlat16_6.x;\n    u_xlat16_29 = (-u_xlat16_29) + u_xlat16_14;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_6.x;\n    u_xlat16_29 = clamp(u_xlat16_29, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_29 * -2.0 + 3.0;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_29;\n    u_xlat16_26 = floor(u_xlat16_26);\n    u_xlat16_26 = u_xlat16_6.x * u_xlat16_29 + u_xlat16_26;\n    u_xlat16_26 = u_xlat16_26 / _RampBands;\n    u_xlat16_26 = clamp(u_xlat16_26, 0.0, 1.0);\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_6.xyz = vec3(u_xlat16_26) * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_6.xyz = u_xlat16_6.xyz * _LightColor0.xyz;\n    u_xlat16_6.xyz = u_xlat16_4.xyz * u_xlat16_6.xyz;\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_2.xyz : u_xlat16_5.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_7.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_7.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_7.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_7.xyz = max(u_xlat16_7.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_4.xyz = u_xlat16_4.xyz * u_xlat16_7.xyz;\n    u_xlat16_4.xyz = u_xlat16_4.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_6.xyz;\n    u_xlat16_4.xyz = (u_xlatb0.y) ? u_xlat16_4.xyz : u_xlat16_6.xyz;\n    u_xlatb0.x = _SpecularMapType>=5.0;\n    if(u_xlatb0.x){\n        u_xlat10_0 = texture2D(_SpecGlossMap, vs_TEXCOORD1.xy).w;\n        u_xlat16_26 = u_xlat10_0;\n    } else {\n        u_xlatb0.x = _SpecularMapType>=4.0;\n        if(u_xlatb0.x){\n            u_xlat10_0 = texture2D(_SpecGlossMap, vs_TEXCOORD1.xy).z;\n            u_xlat16_26 = u_xlat10_0;\n        } else {\n            u_xlatb0.x = _SpecularMapType>=3.0;\n            if(u_xlatb0.x){\n                u_xlat10_0 = texture2D(_SpecGlossMap, vs_TEXCOORD1.xy).y;\n                u_xlat16_26 = u_xlat10_0;\n            } else {\n                u_xlatb0.x = _SpecularMapType>=2.0;\n                if(u_xlatb0.x){\n                    u_xlat10_0 = texture2D(_SpecGlossMap, vs_TEXCOORD1.xy).x;\n                    u_xlat16_26 = u_xlat10_0;\n                } else {\n                    u_xlatb0.x = _SpecularMapType>=1.0;\n                    u_xlat16_26 = (u_xlatb0.x) ? u_xlat10_3.w : 1.0;\n                }\n            }\n        }\n    }\n    u_xlat16_2.xyz = _WorldSpaceLightPos0.xyz * vec3(u_xlat24) + u_xlat16_2.xyz;\n    u_xlat16_29 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);\n    u_xlat0.x = max(u_xlat16_29, 0.00100000005);\n    u_xlat16_29 = inversesqrt(u_xlat0.x);\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(u_xlat16_29);\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat16_2.xyz);\n    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\n    u_xlat16_2.x = (-_SpecularToonSize) * u_xlat16_26 + 1.0;\n    u_xlat16_10 = (-u_xlat16_2.x) + 1.0;\n    u_xlat16_18 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_2.x / u_xlat16_10;\n    u_xlat16_2.x = u_xlat0.x * u_xlat16_18 + (-u_xlat16_2.x);\n    u_xlat0.x = float(1.0) / _SpecularToonSmoothness;\n    u_xlat0.x = u_xlat0.x * u_xlat16_2.x;\n    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\n    u_xlat8 = u_xlat0.x * -2.0 + 3.0;\n    u_xlat0.x = u_xlat0.x * u_xlat0.x;\n    u_xlat0.x = u_xlat0.x * u_xlat8;\n    u_xlat16_2.x = u_xlat16_28 * u_xlat0.x;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _LightColor0.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * _SpecularColor.xyz + u_xlat16_4.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 unity_SHAr;\nuniform \tmediump vec4 unity_SHAg;\nuniform \tmediump vec4 unity_SHAb;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _SColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump vec4 _SpecularColor;\nuniform \tmediump float _SpecularMapType;\nuniform \tmediump float _SpecularToonSize;\nuniform \tmediump float _SpecularToonSmoothness;\nuniform \tmediump float _IndirectIntensity;\nuniform \tmediump float _SingleIndirectColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nUNITY_LOCATION(2) uniform mediump sampler2D _SpecGlossMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump float u_xlat16_0;\nbvec2 u_xlatb0;\nvec4 u_xlat1;\nmediump vec3 u_xlat16_2;\nvec2 u_xlat3;\nmediump vec4 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nfloat u_xlat8;\nmediump float u_xlat16_10;\nmediump vec3 u_xlat16_13;\nmediump float u_xlat16_14;\nmediump float u_xlat16_18;\nfloat u_xlat24;\nmediump float u_xlat16_26;\nmediump float u_xlat16_28;\nmediump float u_xlat16_29;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat24 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat24) * u_xlat0.xyz;\n    u_xlat1.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_2.x = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat24 = max(u_xlat16_2.x, 0.00100000005);\n    u_xlat16_2.x = inversesqrt(u_xlat24);\n    u_xlat16_2.xyz = u_xlat1.xyz * u_xlat16_2.xxx;\n    u_xlat24 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat24 = inversesqrt(u_xlat24);\n    u_xlat1.xyz = vec3(u_xlat24) * _WorldSpaceLightPos0.xyz;\n    u_xlat16_3 = texture(_BaseMap, vs_TEXCOORD1.xy);\n    u_xlat16_4.xyz = u_xlat16_3.xyz * _BaseColor.xyz;\n    u_xlat3.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_3.xy = texture(_BumpMap, u_xlat3.xy).yw;\n    u_xlat16_5.xy = u_xlat16_3.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_26 = dot(u_xlat16_5.xy, u_xlat16_5.xy);\n    u_xlat16_26 = min(u_xlat16_26, 1.0);\n    u_xlat16_26 = (-u_xlat16_26) + 1.0;\n    u_xlat16_26 = sqrt(u_xlat16_26);\n    u_xlat16_5.xy = u_xlat16_5.xy * vec2(_BumpScale);\n    u_xlat16_13.xyz = u_xlat16_5.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_5.xyz = u_xlat16_5.xxx * vs_TEXCOORD2.xyz + u_xlat16_13.xyz;\n    u_xlat16_5.xyz = vec3(u_xlat16_26) * u_xlat0.xyz + u_xlat16_5.xyz;\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat1.xyz);\n    u_xlat16_26 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_28 = u_xlat0.x;\n    u_xlat16_28 = clamp(u_xlat16_28, 0.0, 1.0);\n    u_xlat16_29 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_6.x = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_29) + u_xlat16_6.x;\n    u_xlat16_26 = u_xlat16_26 + (-u_xlat16_29);\n    u_xlat16_29 = float(1.0) / u_xlat16_6.x;\n    u_xlat16_26 = u_xlat16_26 * u_xlat16_29;\n    u_xlat16_26 = clamp(u_xlat16_26, 0.0, 1.0);\n    u_xlat16_29 = u_xlat16_26 * -2.0 + 3.0;\n    u_xlat16_26 = u_xlat16_26 * u_xlat16_26;\n    u_xlat16_26 = u_xlat16_26 * u_xlat16_29;\n    u_xlat16_29 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_6.x = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_26 = u_xlat16_26 * _RampBands;\n    u_xlat16_14 = fract(u_xlat16_26);\n    u_xlat16_6.x = (-u_xlat16_29) + u_xlat16_6.x;\n    u_xlat16_29 = (-u_xlat16_29) + u_xlat16_14;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_6.x;\n    u_xlat16_29 = clamp(u_xlat16_29, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_29 * -2.0 + 3.0;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_29;\n    u_xlat16_26 = floor(u_xlat16_26);\n    u_xlat16_26 = u_xlat16_6.x * u_xlat16_29 + u_xlat16_26;\n    u_xlat16_26 = u_xlat16_26 / _RampBands;\n    u_xlat16_26 = clamp(u_xlat16_26, 0.0, 1.0);\n    u_xlat16_6.xyz = (-_SColor.xyz) + _HColor.xyz;\n    u_xlat16_6.xyz = vec3(u_xlat16_26) * u_xlat16_6.xyz + _SColor.xyz;\n    u_xlat16_6.xyz = u_xlat16_6.xyz * _LightColor0.xyz;\n    u_xlat16_6.xyz = u_xlat16_4.xyz * u_xlat16_6.xyz;\n    u_xlatb0.xy = lessThan(vec4(0.0, 0.0, 0.0, 0.0), vec4(_SingleIndirectColor, _IndirectIntensity, _SingleIndirectColor, _SingleIndirectColor)).xy;\n    u_xlat1.xyz = (u_xlatb0.x) ? u_xlat16_2.xyz : u_xlat16_5.xyz;\n    u_xlat1.w = 1.0;\n    u_xlat16_7.x = dot(unity_SHAr, u_xlat1);\n    u_xlat16_7.y = dot(unity_SHAg, u_xlat1);\n    u_xlat16_7.z = dot(unity_SHAb, u_xlat1);\n    u_xlat16_7.xyz = max(u_xlat16_7.xyz, vec3(0.0, 0.0, 0.0));\n    u_xlat16_4.xyz = u_xlat16_4.xyz * u_xlat16_7.xyz;\n    u_xlat16_4.xyz = u_xlat16_4.xyz * vec3(vec3(_IndirectIntensity, _IndirectIntensity, _IndirectIntensity)) + u_xlat16_6.xyz;\n    u_xlat16_4.xyz = (u_xlatb0.y) ? u_xlat16_4.xyz : u_xlat16_6.xyz;\n    u_xlatb0.x = _SpecularMapType>=5.0;\n    if(u_xlatb0.x){\n        u_xlat16_0 = texture(_SpecGlossMap, vs_TEXCOORD1.xy).w;\n        u_xlat16_26 = u_xlat16_0;\n    } else {\n        u_xlatb0.x = _SpecularMapType>=4.0;\n        if(u_xlatb0.x){\n            u_xlat16_0 = texture(_SpecGlossMap, vs_TEXCOORD1.xy).z;\n            u_xlat16_26 = u_xlat16_0;\n        } else {\n            u_xlatb0.x = _SpecularMapType>=3.0;\n            if(u_xlatb0.x){\n                u_xlat16_0 = texture(_SpecGlossMap, vs_TEXCOORD1.xy).y;\n                u_xlat16_26 = u_xlat16_0;\n            } else {\n                u_xlatb0.x = _SpecularMapType>=2.0;\n                if(u_xlatb0.x){\n                    u_xlat16_0 = texture(_SpecGlossMap, vs_TEXCOORD1.xy).x;\n                    u_xlat16_26 = u_xlat16_0;\n                } else {\n                    u_xlatb0.x = _SpecularMapType>=1.0;\n                    u_xlat16_26 = (u_xlatb0.x) ? u_xlat16_3.w : 1.0;\n                }\n            }\n        }\n    }\n    u_xlat16_2.xyz = _WorldSpaceLightPos0.xyz * vec3(u_xlat24) + u_xlat16_2.xyz;\n    u_xlat16_29 = dot(u_xlat16_2.xyz, u_xlat16_2.xyz);\n    u_xlat0.x = max(u_xlat16_29, 0.00100000005);\n    u_xlat16_29 = inversesqrt(u_xlat0.x);\n    u_xlat16_2.xyz = u_xlat16_2.xyz * vec3(u_xlat16_29);\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat16_2.xyz);\n    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\n    u_xlat16_2.x = (-_SpecularToonSize) * u_xlat16_26 + 1.0;\n    u_xlat16_10 = (-u_xlat16_2.x) + 1.0;\n    u_xlat16_18 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_2.x / u_xlat16_10;\n    u_xlat16_2.x = u_xlat0.x * u_xlat16_18 + (-u_xlat16_2.x);\n    u_xlat0.x = float(1.0) / _SpecularToonSmoothness;\n    u_xlat0.x = u_xlat0.x * u_xlat16_2.x;\n    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\n    u_xlat8 = u_xlat0.x * -2.0 + 3.0;\n    u_xlat0.x = u_xlat0.x * u_xlat0.x;\n    u_xlat0.x = u_xlat0.x * u_xlat8;\n    u_xlat16_2.x = u_xlat16_28 * u_xlat0.x;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _LightColor0.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * _SpecularColor.xyz + u_xlat16_4.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = _LightColor0.xyz * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_6.xyz * u_xlat16_2.xxx;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = _LightColor0.xyz * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_6.xyz * u_xlat16_2.xxx;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec2 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = _LightColor0.xyz * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_6.xyz * u_xlat16_2.xxx;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec2 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = _LightColor0.xyz * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_6.xyz * u_xlat16_2.xxx;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = _LightColor0.xyz * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_6.xyz * u_xlat16_2.xxx;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6.x) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6.x = (-u_xlat16_6.x) + u_xlat16_10;\n    u_xlat16_6.x = float(1.0) / u_xlat16_6.x;\n    u_xlat16_2.x = u_xlat16_6.x * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6.x = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6.x;\n    u_xlat16_6.xyz = _LightColor0.xyz * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_6.xyz * u_xlat16_2.xxx;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6 = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6 = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec2 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6 = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec2 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6 = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tvec4 _EmissionMap_ST;\nuniform \tmediump float _EmissionChannel;\nuniform \tmediump vec4 _EmissionColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _EmissionMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nvec3 u_xlat1;\nvec2 u_xlat2;\nlowp vec4 u_xlat10_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nbvec4 u_xlatb7;\nmediump vec3 u_xlat16_8;\nmediump vec3 u_xlat16_9;\nmediump float u_xlat16_15;\nfloat u_xlat30;\nbool u_xlatb30;\nmediump float u_xlat16_33;\nmediump float u_xlat16_34;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat30 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat30) * u_xlat0.xyz;\n    u_xlat30 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat30 = inversesqrt(u_xlat30);\n    u_xlat1.xyz = vec3(u_xlat30) * _WorldSpaceLightPos0.xyz;\n    u_xlat10_2.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_2.xyz * _BaseColor.xyz;\n    u_xlatb30 = _EmissionChannel<5.0;\n    if(u_xlatb30){\n        u_xlat2.xy = vs_TEXCOORD1.zw * _EmissionMap_ST.xy + _EmissionMap_ST.zw;\n        u_xlat10_2 = texture2D(_EmissionMap, u_xlat2.xy);\n        u_xlat16_4.xyz = u_xlat10_2.xyz * _EmissionColor.xyz;\n        u_xlat16_5.xyz = u_xlat10_2.www * _EmissionColor.xyz;\n        u_xlat16_6.xyz = u_xlat10_2.zzz * _EmissionColor.xyz;\n        u_xlatb7 = greaterThanEqual(vec4(_EmissionChannel), vec4(4.0, 3.0, 2.0, 1.0));\n        u_xlat16_8.xyz = u_xlat10_2.yyy * _EmissionColor.xyz;\n        u_xlat16_9.xyz = u_xlat10_2.xxx * _EmissionColor.xyz;\n        u_xlat16_8.xyz = (u_xlatb7.w) ? u_xlat16_8.xyz : u_xlat16_9.xyz;\n        u_xlat16_6.xyz = (u_xlatb7.z) ? u_xlat16_6.xyz : u_xlat16_8.xyz;\n        u_xlat16_5.xyz = (u_xlatb7.y) ? u_xlat16_5.xyz : u_xlat16_6.xyz;\n        u_xlat16_4.xyz = (u_xlatb7.x) ? u_xlat16_4.xyz : u_xlat16_5.xyz;\n    } else {\n        u_xlat16_4.xyz = _EmissionColor.xyz;\n    }\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_33 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_34 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_5.x = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_5.x = (-u_xlat16_34) + u_xlat16_5.x;\n    u_xlat16_33 = u_xlat16_33 + (-u_xlat16_34);\n    u_xlat16_34 = float(1.0) / u_xlat16_5.x;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_34;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_34 = u_xlat16_33 * -2.0 + 3.0;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_34;\n    u_xlat16_34 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_5.x = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_33 = u_xlat16_33 * _RampBands;\n    u_xlat16_15 = fract(u_xlat16_33);\n    u_xlat16_5.x = (-u_xlat16_34) + u_xlat16_5.x;\n    u_xlat16_34 = (-u_xlat16_34) + u_xlat16_15;\n    u_xlat16_5.x = float(1.0) / u_xlat16_5.x;\n    u_xlat16_34 = u_xlat16_34 * u_xlat16_5.x;\n    u_xlat16_34 = clamp(u_xlat16_34, 0.0, 1.0);\n    u_xlat16_5.x = u_xlat16_34 * -2.0 + 3.0;\n    u_xlat16_34 = u_xlat16_34 * u_xlat16_34;\n    u_xlat16_33 = floor(u_xlat16_33);\n    u_xlat16_33 = u_xlat16_5.x * u_xlat16_34 + u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 / _RampBands;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_5.xyz = vec3(u_xlat16_33) * _HColor.xyz;\n    u_xlat16_5.xyz = u_xlat16_5.xyz * _LightColor0.xyz;\n    SV_Target0.xyz = u_xlat16_3.xyz * u_xlat16_5.xyz + u_xlat16_4.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tvec4 _EmissionMap_ST;\nuniform \tmediump float _EmissionChannel;\nuniform \tmediump vec4 _EmissionColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _EmissionMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nvec3 u_xlat1;\nvec2 u_xlat2;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nbvec4 u_xlatb7;\nmediump vec3 u_xlat16_8;\nmediump vec3 u_xlat16_9;\nmediump float u_xlat16_15;\nfloat u_xlat30;\nbool u_xlatb30;\nmediump float u_xlat16_33;\nmediump float u_xlat16_34;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat30 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat30) * u_xlat0.xyz;\n    u_xlat30 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat30 = inversesqrt(u_xlat30);\n    u_xlat1.xyz = vec3(u_xlat30) * _WorldSpaceLightPos0.xyz;\n    u_xlat16_2.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_2.xyz * _BaseColor.xyz;\n    u_xlatb30 = _EmissionChannel<5.0;\n    if(u_xlatb30){\n        u_xlat2.xy = vs_TEXCOORD1.zw * _EmissionMap_ST.xy + _EmissionMap_ST.zw;\n        u_xlat16_2 = texture(_EmissionMap, u_xlat2.xy);\n        u_xlat16_4.xyz = u_xlat16_2.xyz * _EmissionColor.xyz;\n        u_xlat16_5.xyz = u_xlat16_2.www * _EmissionColor.xyz;\n        u_xlat16_6.xyz = u_xlat16_2.zzz * _EmissionColor.xyz;\n        u_xlatb7 = greaterThanEqual(vec4(_EmissionChannel), vec4(4.0, 3.0, 2.0, 1.0));\n        u_xlat16_8.xyz = u_xlat16_2.yyy * _EmissionColor.xyz;\n        u_xlat16_9.xyz = u_xlat16_2.xxx * _EmissionColor.xyz;\n        u_xlat16_8.xyz = (u_xlatb7.w) ? u_xlat16_8.xyz : u_xlat16_9.xyz;\n        u_xlat16_6.xyz = (u_xlatb7.z) ? u_xlat16_6.xyz : u_xlat16_8.xyz;\n        u_xlat16_5.xyz = (u_xlatb7.y) ? u_xlat16_5.xyz : u_xlat16_6.xyz;\n        u_xlat16_4.xyz = (u_xlatb7.x) ? u_xlat16_4.xyz : u_xlat16_5.xyz;\n    } else {\n        u_xlat16_4.xyz = _EmissionColor.xyz;\n    }\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_33 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_34 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_5.x = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_5.x = (-u_xlat16_34) + u_xlat16_5.x;\n    u_xlat16_33 = u_xlat16_33 + (-u_xlat16_34);\n    u_xlat16_34 = float(1.0) / u_xlat16_5.x;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_34;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_34 = u_xlat16_33 * -2.0 + 3.0;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_34;\n    u_xlat16_34 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_5.x = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_33 = u_xlat16_33 * _RampBands;\n    u_xlat16_15 = fract(u_xlat16_33);\n    u_xlat16_5.x = (-u_xlat16_34) + u_xlat16_5.x;\n    u_xlat16_34 = (-u_xlat16_34) + u_xlat16_15;\n    u_xlat16_5.x = float(1.0) / u_xlat16_5.x;\n    u_xlat16_34 = u_xlat16_34 * u_xlat16_5.x;\n    u_xlat16_34 = clamp(u_xlat16_34, 0.0, 1.0);\n    u_xlat16_5.x = u_xlat16_34 * -2.0 + 3.0;\n    u_xlat16_34 = u_xlat16_34 * u_xlat16_34;\n    u_xlat16_33 = floor(u_xlat16_33);\n    u_xlat16_33 = u_xlat16_5.x * u_xlat16_34 + u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 / _RampBands;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_5.xyz = vec3(u_xlat16_33) * _HColor.xyz;\n    u_xlat16_5.xyz = u_xlat16_5.xyz * _LightColor0.xyz;\n    SV_Target0.xyz = u_xlat16_3.xyz * u_xlat16_5.xyz + u_xlat16_4.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tvec4 _EmissionMap_ST;\nuniform \tmediump float _EmissionChannel;\nuniform \tmediump vec4 _EmissionColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nuniform lowp sampler2D _EmissionMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec4 u_xlat10_0;\nbool u_xlatb0;\nvec3 u_xlat1;\nvec2 u_xlat2;\nlowp vec3 u_xlat10_2;\nbvec4 u_xlatb2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nmediump vec3 u_xlat16_8;\nmediump vec3 u_xlat16_9;\nmediump vec3 u_xlat16_14;\nmediump float u_xlat16_24;\nfloat u_xlat30;\nmediump float u_xlat16_33;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat30 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat30) * u_xlat0.xyz;\n    u_xlat30 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat30 = inversesqrt(u_xlat30);\n    u_xlat1.xyz = vec3(u_xlat30) * _WorldSpaceLightPos0.xyz;\n    u_xlat10_2.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_2.xyz * _BaseColor.xyz;\n    u_xlat2.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_2.xy = texture2D(_BumpMap, u_xlat2.xy).yw;\n    u_xlat16_4.xy = u_xlat10_2.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_33 = dot(u_xlat16_4.xy, u_xlat16_4.xy);\n    u_xlat16_33 = min(u_xlat16_33, 1.0);\n    u_xlat16_33 = (-u_xlat16_33) + 1.0;\n    u_xlat16_33 = sqrt(u_xlat16_33);\n    u_xlat16_4.xy = u_xlat16_4.xy * vec2(_BumpScale);\n    u_xlat16_14.xyz = u_xlat16_4.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_4.xyz = u_xlat16_4.xxx * vs_TEXCOORD2.xyz + u_xlat16_14.xyz;\n    u_xlat16_4.xyz = vec3(u_xlat16_33) * u_xlat0.xyz + u_xlat16_4.xyz;\n    u_xlatb0 = _EmissionChannel<5.0;\n    if(u_xlatb0){\n        u_xlat0.xy = vs_TEXCOORD1.zw * _EmissionMap_ST.xy + _EmissionMap_ST.zw;\n        u_xlat10_0 = texture2D(_EmissionMap, u_xlat0.xy);\n        u_xlat16_5.xyz = u_xlat10_0.xyz * _EmissionColor.xyz;\n        u_xlat16_6.xyz = u_xlat10_0.www * _EmissionColor.xyz;\n        u_xlat16_7.xyz = u_xlat10_0.zzz * _EmissionColor.xyz;\n        u_xlatb2 = greaterThanEqual(vec4(_EmissionChannel), vec4(4.0, 3.0, 2.0, 1.0));\n        u_xlat16_8.xyz = u_xlat10_0.yyy * _EmissionColor.xyz;\n        u_xlat16_9.xyz = u_xlat10_0.xxx * _EmissionColor.xyz;\n        u_xlat16_8.xyz = (u_xlatb2.w) ? u_xlat16_8.xyz : u_xlat16_9.xyz;\n        u_xlat16_7.xyz = (u_xlatb2.z) ? u_xlat16_7.xyz : u_xlat16_8.xyz;\n        u_xlat16_6.xyz = (u_xlatb2.y) ? u_xlat16_6.xyz : u_xlat16_7.xyz;\n        u_xlat16_5.xyz = (u_xlatb2.x) ? u_xlat16_5.xyz : u_xlat16_6.xyz;\n    } else {\n        u_xlat16_5.xyz = _EmissionColor.xyz;\n    }\n    u_xlat0.x = dot(u_xlat16_4.xyz, u_xlat1.xyz);\n    u_xlat16_33 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_4.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_14.x = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_14.x = (-u_xlat16_4.x) + u_xlat16_14.x;\n    u_xlat16_33 = u_xlat16_33 + (-u_xlat16_4.x);\n    u_xlat16_4.x = float(1.0) / u_xlat16_14.x;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_4.x;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_4.x = u_xlat16_33 * -2.0 + 3.0;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_4.x;\n    u_xlat16_4.x = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_14.x = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_33 = u_xlat16_33 * _RampBands;\n    u_xlat16_24 = fract(u_xlat16_33);\n    u_xlat16_14.x = (-u_xlat16_4.x) + u_xlat16_14.x;\n    u_xlat16_4.x = (-u_xlat16_4.x) + u_xlat16_24;\n    u_xlat16_14.x = float(1.0) / u_xlat16_14.x;\n    u_xlat16_4.x = u_xlat16_14.x * u_xlat16_4.x;\n    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0, 1.0);\n    u_xlat16_14.x = u_xlat16_4.x * -2.0 + 3.0;\n    u_xlat16_4.x = u_xlat16_4.x * u_xlat16_4.x;\n    u_xlat16_33 = floor(u_xlat16_33);\n    u_xlat16_33 = u_xlat16_14.x * u_xlat16_4.x + u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 / _RampBands;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_4.xyz = vec3(u_xlat16_33) * _HColor.xyz;\n    u_xlat16_4.xyz = u_xlat16_4.xyz * _LightColor0.xyz;\n    SV_Target0.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz + u_xlat16_5.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tvec4 _EmissionMap_ST;\nuniform \tmediump float _EmissionChannel;\nuniform \tmediump vec4 _EmissionColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nUNITY_LOCATION(2) uniform mediump sampler2D _EmissionMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec4 u_xlat16_0;\nbool u_xlatb0;\nvec3 u_xlat1;\nvec2 u_xlat2;\nmediump vec3 u_xlat16_2;\nbvec4 u_xlatb2;\nmediump vec3 u_xlat16_3;\nmediump vec3 u_xlat16_4;\nmediump vec3 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nmediump vec3 u_xlat16_8;\nmediump vec3 u_xlat16_9;\nmediump vec3 u_xlat16_14;\nmediump float u_xlat16_24;\nfloat u_xlat30;\nmediump float u_xlat16_33;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat30 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat30) * u_xlat0.xyz;\n    u_xlat30 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat30 = inversesqrt(u_xlat30);\n    u_xlat1.xyz = vec3(u_xlat30) * _WorldSpaceLightPos0.xyz;\n    u_xlat16_2.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_2.xyz * _BaseColor.xyz;\n    u_xlat2.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_2.xy = texture(_BumpMap, u_xlat2.xy).yw;\n    u_xlat16_4.xy = u_xlat16_2.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_33 = dot(u_xlat16_4.xy, u_xlat16_4.xy);\n    u_xlat16_33 = min(u_xlat16_33, 1.0);\n    u_xlat16_33 = (-u_xlat16_33) + 1.0;\n    u_xlat16_33 = sqrt(u_xlat16_33);\n    u_xlat16_4.xy = u_xlat16_4.xy * vec2(_BumpScale);\n    u_xlat16_14.xyz = u_xlat16_4.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_4.xyz = u_xlat16_4.xxx * vs_TEXCOORD2.xyz + u_xlat16_14.xyz;\n    u_xlat16_4.xyz = vec3(u_xlat16_33) * u_xlat0.xyz + u_xlat16_4.xyz;\n    u_xlatb0 = _EmissionChannel<5.0;\n    if(u_xlatb0){\n        u_xlat0.xy = vs_TEXCOORD1.zw * _EmissionMap_ST.xy + _EmissionMap_ST.zw;\n        u_xlat16_0 = texture(_EmissionMap, u_xlat0.xy);\n        u_xlat16_5.xyz = u_xlat16_0.xyz * _EmissionColor.xyz;\n        u_xlat16_6.xyz = u_xlat16_0.www * _EmissionColor.xyz;\n        u_xlat16_7.xyz = u_xlat16_0.zzz * _EmissionColor.xyz;\n        u_xlatb2 = greaterThanEqual(vec4(_EmissionChannel), vec4(4.0, 3.0, 2.0, 1.0));\n        u_xlat16_8.xyz = u_xlat16_0.yyy * _EmissionColor.xyz;\n        u_xlat16_9.xyz = u_xlat16_0.xxx * _EmissionColor.xyz;\n        u_xlat16_8.xyz = (u_xlatb2.w) ? u_xlat16_8.xyz : u_xlat16_9.xyz;\n        u_xlat16_7.xyz = (u_xlatb2.z) ? u_xlat16_7.xyz : u_xlat16_8.xyz;\n        u_xlat16_6.xyz = (u_xlatb2.y) ? u_xlat16_6.xyz : u_xlat16_7.xyz;\n        u_xlat16_5.xyz = (u_xlatb2.x) ? u_xlat16_5.xyz : u_xlat16_6.xyz;\n    } else {\n        u_xlat16_5.xyz = _EmissionColor.xyz;\n    }\n    u_xlat0.x = dot(u_xlat16_4.xyz, u_xlat1.xyz);\n    u_xlat16_33 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_4.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_14.x = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_14.x = (-u_xlat16_4.x) + u_xlat16_14.x;\n    u_xlat16_33 = u_xlat16_33 + (-u_xlat16_4.x);\n    u_xlat16_4.x = float(1.0) / u_xlat16_14.x;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_4.x;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_4.x = u_xlat16_33 * -2.0 + 3.0;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 * u_xlat16_4.x;\n    u_xlat16_4.x = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_14.x = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_33 = u_xlat16_33 * _RampBands;\n    u_xlat16_24 = fract(u_xlat16_33);\n    u_xlat16_14.x = (-u_xlat16_4.x) + u_xlat16_14.x;\n    u_xlat16_4.x = (-u_xlat16_4.x) + u_xlat16_24;\n    u_xlat16_14.x = float(1.0) / u_xlat16_14.x;\n    u_xlat16_4.x = u_xlat16_14.x * u_xlat16_4.x;\n    u_xlat16_4.x = clamp(u_xlat16_4.x, 0.0, 1.0);\n    u_xlat16_14.x = u_xlat16_4.x * -2.0 + 3.0;\n    u_xlat16_4.x = u_xlat16_4.x * u_xlat16_4.x;\n    u_xlat16_33 = floor(u_xlat16_33);\n    u_xlat16_33 = u_xlat16_14.x * u_xlat16_4.x + u_xlat16_33;\n    u_xlat16_33 = u_xlat16_33 / _RampBands;\n    u_xlat16_33 = clamp(u_xlat16_33, 0.0, 1.0);\n    u_xlat16_4.xyz = vec3(u_xlat16_33) * _HColor.xyz;\n    u_xlat16_4.xyz = u_xlat16_4.xyz * _LightColor0.xyz;\n    SV_Target0.xyz = u_xlat16_3.xyz * u_xlat16_4.xyz + u_xlat16_5.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec2 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec2 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6 = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6 = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec2 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6 = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec2 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nmediump float u_xlat16_14;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x * _RampBands;\n    u_xlat16_6 = floor(u_xlat16_2.x);\n    u_xlat16_2.x = fract(u_xlat16_2.x);\n    u_xlat16_10 = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_2.x = (-u_xlat16_10) + u_xlat16_2.x;\n    u_xlat16_14 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_10 = (-u_xlat16_10) + u_xlat16_14;\n    u_xlat16_10 = float(1.0) / u_xlat16_10;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_10 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_10 * u_xlat16_2.x + u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_2.x / _RampBands;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nfloat u_xlat6;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat6 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat6 = inversesqrt(u_xlat6);\n    vs_NORMAL0.xyz = vec3(u_xlat6) * u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec3 u_xlat1;\nmediump vec3 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat12 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat0.xyz, u_xlat1.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp vec3 u_xlat10_0;\nvec2 u_xlat1;\nlowp vec2 u_xlat10_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_1.xy = texture2D(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat10_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat10_0.xyz = texture2D(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat10_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump vec3 u_xlat16_0;\nvec2 u_xlat1;\nmediump vec2 u_xlat16_1;\nmediump vec4 u_xlat16_2;\nmediump vec3 u_xlat16_3;\nmediump float u_xlat16_6;\nmediump float u_xlat16_10;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat12 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    u_xlat1.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_1.xy = texture(_BumpMap, u_xlat1.xy).yw;\n    u_xlat16_2.xy = u_xlat16_1.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_10 = dot(u_xlat16_2.xy, u_xlat16_2.xy);\n    u_xlat16_2.xy = u_xlat16_2.xy * vec2(_BumpScale);\n    u_xlat16_10 = min(u_xlat16_10, 1.0);\n    u_xlat16_10 = (-u_xlat16_10) + 1.0;\n    u_xlat16_10 = sqrt(u_xlat16_10);\n    u_xlat16_3.xyz = u_xlat16_2.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_2.xyw = u_xlat16_2.xxx * vs_TEXCOORD2.xyz + u_xlat16_3.xyz;\n    u_xlat16_2.xyz = vec3(u_xlat16_10) * u_xlat0.xyz + u_xlat16_2.xyw;\n    u_xlat0.x = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * _WorldSpaceLightPos0.xyz;\n    u_xlat0.x = dot(u_xlat16_2.xyz, u_xlat0.xyz);\n    u_xlat16_2.x = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6 = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_2.x = (-u_xlat16_6) + u_xlat16_2.x;\n    u_xlat16_10 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_6 = (-u_xlat16_6) + u_xlat16_10;\n    u_xlat16_6 = float(1.0) / u_xlat16_6;\n    u_xlat16_2.x = u_xlat16_6 * u_xlat16_2.x;\n    u_xlat16_2.x = clamp(u_xlat16_2.x, 0.0, 1.0);\n    u_xlat16_6 = u_xlat16_2.x * -2.0 + 3.0;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_2.x;\n    u_xlat16_2.x = u_xlat16_2.x * u_xlat16_6;\n    u_xlat16_2.xyz = u_xlat16_2.xxx * _HColor.xyz;\n    u_xlat16_2.xyz = u_xlat16_2.xyz * _LightColor0.xyz;\n    u_xlat16_0.xyz = texture(_BaseMap, vs_TEXCOORD1.xy).xyz;\n    u_xlat16_3.xyz = u_xlat16_0.xyz * _BaseColor.xyz;\n    SV_Target0.xyz = u_xlat16_2.xyz * u_xlat16_3.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 100\n\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nattribute highp vec4 in_POSITION0;\nattribute highp vec3 in_NORMAL0;\nattribute highp vec4 in_TANGENT0;\nattribute highp vec4 in_TEXCOORD0;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\nvarying highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 100\n\n#ifdef GL_FRAGMENT_PRECISION_HIGH\n    precision highp float;\n#else\n    precision mediump float;\n#endif\nprecision highp int;\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump vec4 _SpecularColor;\nuniform \tmediump float _SpecularMapType;\nuniform \tmediump float _SpecularToonSize;\nuniform \tmediump float _SpecularToonSmoothness;\nuniform lowp sampler2D _BaseMap;\nuniform lowp sampler2D _BumpMap;\nuniform lowp sampler2D _SpecGlossMap;\nvarying highp vec3 vs_NORMAL0;\nvarying highp vec4 vs_TEXCOORD0;\nvarying highp vec4 vs_TEXCOORD1;\nvarying highp vec4 vs_TEXCOORD2;\nvarying highp vec4 vs_TEXCOORD3;\n#define SV_Target0 gl_FragData[0]\nvec3 u_xlat0;\nlowp float u_xlat10_0;\nbool u_xlatb0;\nvec3 u_xlat1;\nmediump float u_xlat16_2;\nvec3 u_xlat3;\nvec2 u_xlat4;\nlowp vec4 u_xlat10_4;\nmediump vec4 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nfloat u_xlat8;\nmediump vec3 u_xlat16_10;\nmediump float u_xlat16_13;\nmediump vec3 u_xlat16_14;\nmediump float u_xlat16_21;\nmediump float u_xlat16_22;\nfloat u_xlat24;\nmediump float u_xlat16_29;\nmediump float u_xlat16_30;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat24 = ((gl_FrontFacing ? 1 : 0) != 0) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat24) * u_xlat0.xyz;\n    u_xlat1.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_2 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat24 = max(u_xlat16_2, 0.00100000005);\n    u_xlat16_2 = inversesqrt(u_xlat24);\n    u_xlat24 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat24 = inversesqrt(u_xlat24);\n    u_xlat3.xyz = vec3(u_xlat24) * _WorldSpaceLightPos0.xyz;\n    u_xlat10_4 = texture2D(_BaseMap, vs_TEXCOORD1.xy);\n    u_xlat16_10.xyz = u_xlat10_4.xyz * _BaseColor.xyz;\n    u_xlat4.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat10_4.xy = texture2D(_BumpMap, u_xlat4.xy).yw;\n    u_xlat16_5.xy = u_xlat10_4.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_21 = dot(u_xlat16_5.xy, u_xlat16_5.xy);\n    u_xlat16_21 = min(u_xlat16_21, 1.0);\n    u_xlat16_21 = (-u_xlat16_21) + 1.0;\n    u_xlat16_21 = sqrt(u_xlat16_21);\n    u_xlat16_5.xy = u_xlat16_5.xy * vec2(_BumpScale);\n    u_xlat16_6.xyz = u_xlat16_5.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_5.xyw = u_xlat16_5.xxx * vs_TEXCOORD2.xyz + u_xlat16_6.xyz;\n    u_xlat16_5.xyz = vec3(u_xlat16_21) * u_xlat0.xyz + u_xlat16_5.xyw;\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat3.xyz);\n    u_xlat16_29 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = u_xlat0.x;\n    u_xlat16_6.x = clamp(u_xlat16_6.x, 0.0, 1.0);\n    u_xlat16_14.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_22 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_22 = (-u_xlat16_14.x) + u_xlat16_22;\n    u_xlat16_29 = u_xlat16_29 + (-u_xlat16_14.x);\n    u_xlat16_14.x = float(1.0) / u_xlat16_22;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_14.x;\n    u_xlat16_29 = clamp(u_xlat16_29, 0.0, 1.0);\n    u_xlat16_14.x = u_xlat16_29 * -2.0 + 3.0;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_29;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_14.x;\n    u_xlat16_14.x = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_22 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_29 = u_xlat16_29 * _RampBands;\n    u_xlat16_30 = fract(u_xlat16_29);\n    u_xlat16_22 = (-u_xlat16_14.x) + u_xlat16_22;\n    u_xlat16_14.x = (-u_xlat16_14.x) + u_xlat16_30;\n    u_xlat16_22 = float(1.0) / u_xlat16_22;\n    u_xlat16_14.x = u_xlat16_22 * u_xlat16_14.x;\n    u_xlat16_14.x = clamp(u_xlat16_14.x, 0.0, 1.0);\n    u_xlat16_22 = u_xlat16_14.x * -2.0 + 3.0;\n    u_xlat16_14.x = u_xlat16_14.x * u_xlat16_14.x;\n    u_xlat16_29 = floor(u_xlat16_29);\n    u_xlat16_29 = u_xlat16_22 * u_xlat16_14.x + u_xlat16_29;\n    u_xlat16_29 = u_xlat16_29 / _RampBands;\n    u_xlat16_29 = clamp(u_xlat16_29, 0.0, 1.0);\n    u_xlat16_14.xyz = vec3(u_xlat16_29) * _HColor.xyz;\n    u_xlat16_14.xyz = u_xlat16_14.xyz * _LightColor0.xyz;\n    u_xlatb0 = _SpecularMapType>=5.0;\n    if(u_xlatb0){\n        u_xlat10_0 = texture2D(_SpecGlossMap, vs_TEXCOORD1.xy).w;\n        u_xlat16_29 = u_xlat10_0;\n    } else {\n        u_xlatb0 = _SpecularMapType>=4.0;\n        if(u_xlatb0){\n            u_xlat10_0 = texture2D(_SpecGlossMap, vs_TEXCOORD1.xy).z;\n            u_xlat16_29 = u_xlat10_0;\n        } else {\n            u_xlatb0 = _SpecularMapType>=3.0;\n            if(u_xlatb0){\n                u_xlat10_0 = texture2D(_SpecGlossMap, vs_TEXCOORD1.xy).y;\n                u_xlat16_29 = u_xlat10_0;\n            } else {\n                u_xlatb0 = _SpecularMapType>=2.0;\n                if(u_xlatb0){\n                    u_xlat10_0 = texture2D(_SpecGlossMap, vs_TEXCOORD1.xy).x;\n                    u_xlat16_29 = u_xlat10_0;\n                } else {\n                    u_xlatb0 = _SpecularMapType>=1.0;\n                    u_xlat16_29 = (u_xlatb0) ? u_xlat10_4.w : 1.0;\n                }\n            }\n        }\n    }\n    u_xlat16_7.xyz = u_xlat1.xyz * vec3(u_xlat16_2) + u_xlat3.xyz;\n    u_xlat16_2 = dot(u_xlat16_7.xyz, u_xlat16_7.xyz);\n    u_xlat0.x = max(u_xlat16_2, 0.00100000005);\n    u_xlat16_2 = inversesqrt(u_xlat0.x);\n    u_xlat16_7.xyz = vec3(u_xlat16_2) * u_xlat16_7.xyz;\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat16_7.xyz);\n    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\n    u_xlat16_2 = (-_SpecularToonSize) * u_xlat16_29 + 1.0;\n    u_xlat16_5.x = (-u_xlat16_2) + 1.0;\n    u_xlat16_13 = float(1.0) / u_xlat16_5.x;\n    u_xlat16_2 = u_xlat16_2 / u_xlat16_5.x;\n    u_xlat16_2 = u_xlat0.x * u_xlat16_13 + (-u_xlat16_2);\n    u_xlat0.x = float(1.0) / _SpecularToonSmoothness;\n    u_xlat0.x = u_xlat0.x * u_xlat16_2;\n    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\n    u_xlat8 = u_xlat0.x * -2.0 + 3.0;\n    u_xlat0.x = u_xlat0.x * u_xlat0.x;\n    u_xlat0.x = u_xlat0.x * u_xlat8;\n    u_xlat16_2 = u_xlat16_6.x * u_xlat0.x;\n    u_xlat16_5.xyz = vec3(u_xlat16_2) * _LightColor0.xyz;\n    u_xlat16_5.xyz = u_xlat16_5.xyz * _SpecularColor.xyz;\n    SV_Target0.xyz = u_xlat16_10.xyz * u_xlat16_14.xyz + u_xlat16_5.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n","\n#version 300 es\n\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec4 hlslcc_mtx4x4unity_ObjectToWorld[4];\nuniform \tvec4 hlslcc_mtx4x4unity_WorldToObject[4];\nuniform \tvec4 unity_WorldTransformParams;\nuniform \tvec4 hlslcc_mtx4x4unity_MatrixVP[4];\nuniform \tvec4 _BaseMap_ST;\nin highp vec4 in_POSITION0;\nin highp vec3 in_NORMAL0;\nin highp vec4 in_TANGENT0;\nin highp vec4 in_TEXCOORD0;\nout highp vec3 vs_NORMAL0;\nout highp vec4 vs_TEXCOORD0;\nout highp vec4 vs_TEXCOORD1;\nout highp vec4 vs_TEXCOORD2;\nout highp vec4 vs_TEXCOORD3;\nout highp vec4 vs_TEXCOORD7;\nvec3 u_xlat0;\nvec4 u_xlat1;\nvec3 u_xlat2;\nmediump float u_xlat16_3;\nfloat u_xlat12;\nvoid main()\n{\n    u_xlat0.xyz = in_POSITION0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_POSITION0.xxx + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_POSITION0.zzz + u_xlat0.xyz;\n    u_xlat0.xyz = hlslcc_mtx4x4unity_ObjectToWorld[3].xyz * in_POSITION0.www + u_xlat0.xyz;\n    u_xlat1 = u_xlat0.yyyy * hlslcc_mtx4x4unity_MatrixVP[1];\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[0] * u_xlat0.xxxx + u_xlat1;\n    u_xlat1 = hlslcc_mtx4x4unity_MatrixVP[2] * u_xlat0.zzzz + u_xlat1;\n    vs_TEXCOORD0.xyz = u_xlat0.xyz;\n    gl_Position = u_xlat1 + hlslcc_mtx4x4unity_MatrixVP[3];\n    u_xlat0.x = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[0].xyz);\n    u_xlat0.y = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[1].xyz);\n    u_xlat0.z = dot(in_NORMAL0.xyz, hlslcc_mtx4x4unity_WorldToObject[2].xyz);\n    u_xlat12 = dot(u_xlat0.xyz, u_xlat0.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat0.xyz = vec3(u_xlat12) * u_xlat0.xyz;\n    vs_NORMAL0.xyz = u_xlat0.xyz;\n    vs_TEXCOORD0.w = 0.0;\n    vs_TEXCOORD1.xy = in_TEXCOORD0.xy * _BaseMap_ST.xy + _BaseMap_ST.zw;\n    vs_TEXCOORD1.zw = in_TEXCOORD0.xy;\n    u_xlat1.xyz = in_TANGENT0.yyy * hlslcc_mtx4x4unity_ObjectToWorld[1].xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[0].xyz * in_TANGENT0.xxx + u_xlat1.xyz;\n    u_xlat1.xyz = hlslcc_mtx4x4unity_ObjectToWorld[2].xyz * in_TANGENT0.zzz + u_xlat1.xyz;\n    u_xlat12 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat12 = inversesqrt(u_xlat12);\n    u_xlat1.xyz = vec3(u_xlat12) * u_xlat1.xyz;\n    vs_TEXCOORD2.xyz = u_xlat1.xyz;\n    vs_TEXCOORD2.w = 0.0;\n    u_xlat2.xyz = u_xlat0.zxy * u_xlat1.yzx;\n    u_xlat0.xyz = u_xlat0.yzx * u_xlat1.zxy + (-u_xlat2.xyz);\n    u_xlat16_3 = in_TANGENT0.w * unity_WorldTransformParams.w;\n    vs_TEXCOORD3.xyz = u_xlat0.xyz * vec3(u_xlat16_3);\n    vs_TEXCOORD3.w = 0.0;\n    vs_TEXCOORD7 = vec4(0.0, 0.0, 0.0, 0.0);\n    return;\n}\n\n","\n#version 300 es\n\nprecision highp float;\nprecision highp int;\n#define HLSLCC_ENABLE_UNIFORM_BUFFERS 0\n#if HLSLCC_ENABLE_UNIFORM_BUFFERS\n#define UNITY_UNIFORM\n#else\n#define UNITY_UNIFORM uniform\n#endif\n#define UNITY_SUPPORTS_UNIFORM_LOCATION 0\n#if UNITY_SUPPORTS_UNIFORM_LOCATION\n#define UNITY_LOCATION(x) layout(location = x)\n#define UNITY_BINDING(x) layout(binding = x, std140)\n#else\n#define UNITY_LOCATION(x)\n#define UNITY_BINDING(x) layout(std140)\n#endif\nuniform \tvec3 _WorldSpaceCameraPos;\nuniform \tmediump vec4 _WorldSpaceLightPos0;\nuniform \tmediump vec4 _LightColor0;\nuniform \tmediump float _RampSmoothing;\nuniform \tmediump float _RampThreshold;\nuniform \tmediump float _RampBands;\nuniform \tmediump float _RampBandsSmoothing;\nuniform \tvec4 _BumpMap_ST;\nuniform \tmediump float _BumpScale;\nuniform \tmediump vec4 _BaseColor;\nuniform \tmediump vec4 _HColor;\nuniform \tmediump vec4 _SpecularColor;\nuniform \tmediump float _SpecularMapType;\nuniform \tmediump float _SpecularToonSize;\nuniform \tmediump float _SpecularToonSmoothness;\nUNITY_LOCATION(0) uniform mediump sampler2D _BaseMap;\nUNITY_LOCATION(1) uniform mediump sampler2D _BumpMap;\nUNITY_LOCATION(2) uniform mediump sampler2D _SpecGlossMap;\nin highp vec3 vs_NORMAL0;\nin highp vec4 vs_TEXCOORD0;\nin highp vec4 vs_TEXCOORD1;\nin highp vec4 vs_TEXCOORD2;\nin highp vec4 vs_TEXCOORD3;\nlayout(location = 0) out mediump vec4 SV_Target0;\nvec3 u_xlat0;\nmediump float u_xlat16_0;\nbool u_xlatb0;\nvec3 u_xlat1;\nmediump float u_xlat16_2;\nvec3 u_xlat3;\nvec2 u_xlat4;\nmediump vec4 u_xlat16_4;\nmediump vec4 u_xlat16_5;\nmediump vec3 u_xlat16_6;\nmediump vec3 u_xlat16_7;\nfloat u_xlat8;\nmediump vec3 u_xlat16_10;\nmediump float u_xlat16_13;\nmediump vec3 u_xlat16_14;\nmediump float u_xlat16_21;\nmediump float u_xlat16_22;\nfloat u_xlat24;\nmediump float u_xlat16_29;\nmediump float u_xlat16_30;\nvoid main()\n{\n    u_xlat0.x = dot(vs_NORMAL0.xyz, vs_NORMAL0.xyz);\n    u_xlat0.x = inversesqrt(u_xlat0.x);\n    u_xlat0.xyz = u_xlat0.xxx * vs_NORMAL0.xyz;\n    u_xlat24 = ((gl_FrontFacing ? 0xffffffffu : uint(0)) != uint(0)) ? 1.0 : -1.0;\n    u_xlat0.xyz = vec3(u_xlat24) * u_xlat0.xyz;\n    u_xlat1.xyz = (-vs_TEXCOORD0.xyz) + _WorldSpaceCameraPos.xyz;\n    u_xlat16_2 = dot(u_xlat1.xyz, u_xlat1.xyz);\n    u_xlat24 = max(u_xlat16_2, 0.00100000005);\n    u_xlat16_2 = inversesqrt(u_xlat24);\n    u_xlat24 = dot(_WorldSpaceLightPos0.xyz, _WorldSpaceLightPos0.xyz);\n    u_xlat24 = inversesqrt(u_xlat24);\n    u_xlat3.xyz = vec3(u_xlat24) * _WorldSpaceLightPos0.xyz;\n    u_xlat16_4 = texture(_BaseMap, vs_TEXCOORD1.xy);\n    u_xlat16_10.xyz = u_xlat16_4.xyz * _BaseColor.xyz;\n    u_xlat4.xy = vs_TEXCOORD1.zw * _BumpMap_ST.xy + _BumpMap_ST.zw;\n    u_xlat16_4.xy = texture(_BumpMap, u_xlat4.xy).yw;\n    u_xlat16_5.xy = u_xlat16_4.yx * vec2(2.0, 2.0) + vec2(-1.0, -1.0);\n    u_xlat16_21 = dot(u_xlat16_5.xy, u_xlat16_5.xy);\n    u_xlat16_21 = min(u_xlat16_21, 1.0);\n    u_xlat16_21 = (-u_xlat16_21) + 1.0;\n    u_xlat16_21 = sqrt(u_xlat16_21);\n    u_xlat16_5.xy = u_xlat16_5.xy * vec2(_BumpScale);\n    u_xlat16_6.xyz = u_xlat16_5.yyy * vs_TEXCOORD3.xyz;\n    u_xlat16_5.xyw = u_xlat16_5.xxx * vs_TEXCOORD2.xyz + u_xlat16_6.xyz;\n    u_xlat16_5.xyz = vec3(u_xlat16_21) * u_xlat0.xyz + u_xlat16_5.xyw;\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat3.xyz);\n    u_xlat16_29 = u_xlat0.x * 0.5 + 0.5;\n    u_xlat16_6.x = u_xlat0.x;\n    u_xlat16_6.x = clamp(u_xlat16_6.x, 0.0, 1.0);\n    u_xlat16_14.x = (-_RampSmoothing) * 0.5 + _RampThreshold;\n    u_xlat16_22 = _RampSmoothing * 0.5 + _RampThreshold;\n    u_xlat16_22 = (-u_xlat16_14.x) + u_xlat16_22;\n    u_xlat16_29 = u_xlat16_29 + (-u_xlat16_14.x);\n    u_xlat16_14.x = float(1.0) / u_xlat16_22;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_14.x;\n    u_xlat16_29 = clamp(u_xlat16_29, 0.0, 1.0);\n    u_xlat16_14.x = u_xlat16_29 * -2.0 + 3.0;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_29;\n    u_xlat16_29 = u_xlat16_29 * u_xlat16_14.x;\n    u_xlat16_14.x = (-_RampBandsSmoothing) * 0.5 + 0.5;\n    u_xlat16_22 = _RampBandsSmoothing * 0.5 + 0.5;\n    u_xlat16_29 = u_xlat16_29 * _RampBands;\n    u_xlat16_30 = fract(u_xlat16_29);\n    u_xlat16_22 = (-u_xlat16_14.x) + u_xlat16_22;\n    u_xlat16_14.x = (-u_xlat16_14.x) + u_xlat16_30;\n    u_xlat16_22 = float(1.0) / u_xlat16_22;\n    u_xlat16_14.x = u_xlat16_22 * u_xlat16_14.x;\n    u_xlat16_14.x = clamp(u_xlat16_14.x, 0.0, 1.0);\n    u_xlat16_22 = u_xlat16_14.x * -2.0 + 3.0;\n    u_xlat16_14.x = u_xlat16_14.x * u_xlat16_14.x;\n    u_xlat16_29 = floor(u_xlat16_29);\n    u_xlat16_29 = u_xlat16_22 * u_xlat16_14.x + u_xlat16_29;\n    u_xlat16_29 = u_xlat16_29 / _RampBands;\n    u_xlat16_29 = clamp(u_xlat16_29, 0.0, 1.0);\n    u_xlat16_14.xyz = vec3(u_xlat16_29) * _HColor.xyz;\n    u_xlat16_14.xyz = u_xlat16_14.xyz * _LightColor0.xyz;\n    u_xlatb0 = _SpecularMapType>=5.0;\n    if(u_xlatb0){\n        u_xlat16_0 = texture(_SpecGlossMap, vs_TEXCOORD1.xy).w;\n        u_xlat16_29 = u_xlat16_0;\n    } else {\n        u_xlatb0 = _SpecularMapType>=4.0;\n        if(u_xlatb0){\n            u_xlat16_0 = texture(_SpecGlossMap, vs_TEXCOORD1.xy).z;\n            u_xlat16_29 = u_xlat16_0;\n        } else {\n            u_xlatb0 = _SpecularMapType>=3.0;\n            if(u_xlatb0){\n                u_xlat16_0 = texture(_SpecGlossMap, vs_TEXCOORD1.xy).y;\n                u_xlat16_29 = u_xlat16_0;\n            } else {\n                u_xlatb0 = _SpecularMapType>=2.0;\n                if(u_xlatb0){\n                    u_xlat16_0 = texture(_SpecGlossMap, vs_TEXCOORD1.xy).x;\n                    u_xlat16_29 = u_xlat16_0;\n                } else {\n                    u_xlatb0 = _SpecularMapType>=1.0;\n                    u_xlat16_29 = (u_xlatb0) ? u_xlat16_4.w : 1.0;\n                }\n            }\n        }\n    }\n    u_xlat16_7.xyz = u_xlat1.xyz * vec3(u_xlat16_2) + u_xlat3.xyz;\n    u_xlat16_2 = dot(u_xlat16_7.xyz, u_xlat16_7.xyz);\n    u_xlat0.x = max(u_xlat16_2, 0.00100000005);\n    u_xlat16_2 = inversesqrt(u_xlat0.x);\n    u_xlat16_7.xyz = vec3(u_xlat16_2) * u_xlat16_7.xyz;\n    u_xlat0.x = dot(u_xlat16_5.xyz, u_xlat16_7.xyz);\n    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\n    u_xlat16_2 = (-_SpecularToonSize) * u_xlat16_29 + 1.0;\n    u_xlat16_5.x = (-u_xlat16_2) + 1.0;\n    u_xlat16_13 = float(1.0) / u_xlat16_5.x;\n    u_xlat16_2 = u_xlat16_2 / u_xlat16_5.x;\n    u_xlat16_2 = u_xlat0.x * u_xlat16_13 + (-u_xlat16_2);\n    u_xlat0.x = float(1.0) / _SpecularToonSmoothness;\n    u_xlat0.x = u_xlat0.x * u_xlat16_2;\n    u_xlat0.x = clamp(u_xlat0.x, 0.0, 1.0);\n    u_xlat8 = u_xlat0.x * -2.0 + 3.0;\n    u_xlat0.x = u_xlat0.x * u_xlat0.x;\n    u_xlat0.x = u_xlat0.x * u_xlat8;\n    u_xlat16_2 = u_xlat16_6.x * u_xlat0.x;\n    u_xlat16_5.xyz = vec3(u_xlat16_2) * _LightColor0.xyz;\n    u_xlat16_5.xyz = u_xlat16_5.xyz * _SpecularColor.xyz;\n    SV_Target0.xyz = u_xlat16_10.xyz * u_xlat16_14.xyz + u_xlat16_5.xyz;\n    SV_Target0.w = 1.0;\n    return;\n}\n\n"]